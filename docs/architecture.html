<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ploinky Architecture - Technical Deep Dive</title>
    <link rel="stylesheet" href="style.css">
    <style>
        .architecture-diagram {
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            overflow-x: auto;
        }
        .architecture-diagram pre {
            margin: 0;
            font-size: 12px;
            line-height: 1.4;
        }
        .component-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .component-card {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
        }
        .component-card h3 {
            color: #2563eb;
            margin-top: 0;
        }
        .performance-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        .performance-table th,
        .performance-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: left;
        }
        .performance-table th {
            background: #f5f5f5;
            font-weight: 600;
        }
        .code-block {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 6px;
            overflow-x: auto;
            margin: 15px 0;
        }
        .code-block code {
            font-family: 'Courier New', monospace;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <nav class="navbar">
        <div class="nav-container">
            <div class="nav-brand">
                <h1>Ploinky</h1>
            </div>
            <ul class="nav-menu">
                <li><a href="index.html">Home</a></li>
                <li><a href="ploinky-cli.html">CLI Documentation</a></li>
                <li><a href="ploinky-cloud.html">Cloud Platform</a></li>
                <li><a href="architecture.html" class="active">Architecture</a></li>
                <li><a href="https://github.com/PlonkyRepos/ploinky" target="_blank">GitHub</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <section class="content-section">
            <h1>Ploinky Architecture</h1>
            <p class="lead">A comprehensive technical deep dive into Ploinky's system design, components, and architectural decisions.</p>

            <nav class="toc">
                <h3>Table of Contents</h3>
                <ul>
                    <li><a href="#overview">System Overview</a></li>
                    <li><a href="#principles">Design Principles</a></li>
                    <li><a href="#architecture">High-Level Architecture</a></li>
                    <li><a href="#components">Core Components</a></li>
                    <li><a href="#data-flow">Data Flow Architecture</a></li>
                    <li><a href="#concurrency">Concurrency & Performance</a></li>
                    <li><a href="#security">Security Architecture</a></li>
                    <li><a href="#deployment">Deployment Architecture</a></li>
                    <li><a href="#future">Future Roadmap</a></li>
                </ul>
            </nav>
        </section>

        <section id="overview" class="content-section">
            <h2>System Overview</h2>
            <p>Ploinky is a container orchestration platform designed for simplicity and efficiency. It provides a lightweight alternative to Kubernetes for managing containerized applications, with a focus on file-based communication patterns and minimal resource overhead.</p>
            
            <div class="features">
                <div class="feature-card">
                    <h3>🎯 Purpose</h3>
                    <p>Bridge the gap between simple Docker commands and complex Kubernetes deployments</p>
                </div>
                <div class="feature-card">
                    <h3>⚡ Key Innovation</h3>
                    <p>Unique file-based IPC mechanism transitioning to HTTP for both simplicity and scalability</p>
                </div>
                <div class="feature-card">
                    <h3>🔧 Target Users</h3>
                    <p>Developers needing container orchestration without the complexity of enterprise solutions</p>
                </div>
            </div>
        </section>

        <section id="principles" class="content-section">
            <h2>Design Principles</h2>
            
            <div class="component-grid">
                <div class="component-card">
                    <h3>1. Simplicity First</h3>
                    <p>Minimize complexity while maintaining functionality. Every feature must justify its complexity cost.</p>
                </div>
                <div class="component-card">
                    <h3>2. File-Based Communication</h3>
                    <p>Use filesystem as the primary IPC mechanism for reliability and simplicity.</p>
                </div>
                <div class="component-card">
                    <h3>3. Container Agnostic</h3>
                    <p>Support both Docker and Podman transparently without vendor lock-in.</p>
                </div>
                <div class="component-card">
                    <h3>4. Modular Architecture</h3>
                    <p>Clear separation of concerns between components for maintainability.</p>
                </div>
                <div class="component-card">
                    <h3>5. HTTP-Based Control Plane</h3>
                    <p>Simple REST API for all operations, making integration straightforward.</p>
                </div>
                <div class="component-card">
                    <h3>6. Progressive Enhancement</h3>
                    <p>Start simple, scale when needed. No over-engineering upfront.</p>
                </div>
            </div>
        </section>

        <section id="architecture" class="content-section">
            <h2>High-Level Architecture</h2>
            
            <div class="architecture-diagram">
                <pre>
┌─────────────────────────────────────────────────────────────────┐
│                         External Clients                         │
│  (Browser, p-cli, PloinkyClient, curl, 3rd-party integrations)  │
└────────────────────────────┬────────────────────────────────────┘
                             │ HTTP/HTTPS
                             ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Ploinky Cloud Server                         │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    Request Router V2                      │  │
│  │  - Path-based routing (/management, /auth, /agents/*)    │  │
│  │  - Domain/host routing for multi-tenancy                 │  │
│  └──────────────────┬───────────────────────────────────────┘  │
│                     │                                           │
│  ┌──────────────────▼───────────────────────────────────────┐  │
│  │                  Task Orchestrator V2                     │  │
│  │  - Task creation and scheduling                          │  │
│  │  - Deployment management                                 │  │
│  │  - Container lifecycle control                           │  │
│  └──────────────────┬───────────────────────────────────────┘  │
│                     │                                           │
│  ┌──────────────────▼───────────────────────────────────────┐  │
│  │              AgentCore Task Executor                      │  │
│  │  - HTTP → AgentCoreClient translation (transitioning)    │  │
│  │  - Task queue management                                 │  │
│  │  - Result polling and retrieval                          │  │
│  └──────────────────┬───────────────────────────────────────┘  │
└─────────────────────┼───────────────────────────────────────────┘
                      │
                      │ HTTP (future) / Filesystem (current)
                      ▼
┌─────────────────────────────────────────────────────────────────┐
│                         Container Layer                          │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │                    Agent Container                        │  │
│  │  ┌────────────────────────────────────────────────────┐  │  │
│  │  │                   AgentCore                        │  │  │
│  │  │  - HTTP server (future) / File watcher (current)   │  │  │
│  │  │  - Task execution engine                           │  │  │
│  │  │  - Handler invocation                              │  │  │
│  │  └────────────────────────────────────────────────────┘  │  │
│  │  ┌────────────────────────────────────────────────────┐  │  │
│  │  │              Application Code                       │  │  │
│  │  │  - User agents from Git repositories               │  │  │
│  │  │  - Custom business logic                           │  │  │
│  │  └────────────────────────────────────────────────────┘  │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                </pre>
            </div>
        </section>

        <section id="components" class="content-section">
            <h2>Core Components</h2>
            
            <div class="component-grid">
                <div class="component-card">
                    <h3>🌩️ Ploinky Cloud Server</h3>
                    <p><strong>Location:</strong> <code>/cloud</code></p>
                    <p>Central control plane implemented as a Node.js HTTP server with clustering support.</p>
                    <ul>
                        <li>Main server entry point with cluster management</li>
                        <li>HTTP request routing and dispatch</li>
                        <li>Task lifecycle management</li>
                        <li>Configuration persistence</li>
                    </ul>
                </div>

                <div class="component-card">
                    <h3>📦 Container Management</h3>
                    <p><strong>Location:</strong> <code>/cloud/container</code></p>
                    <p>Abstracts container runtime operations for both Docker and Podman.</p>
                    <ul>
                        <li>Container lifecycle operations</li>
                        <li>Git repository cloning and sync</li>
                        <li>Volume mounting strategies</li>
                        <li>Port management and caching</li>
                    </ul>
                </div>

                <div class="component-card">
                    <h3>⚙️ AgentCore</h3>
                    <p><strong>Location:</strong> <code>/agentCore</code></p>
                    <p>Runtime engine that executes inside containers.</p>
                    <ul>
                        <li>File-based task watching (current)</li>
                        <li>HTTP server (future)</li>
                        <li>Task execution engine</li>
                        <li>Result management</li>
                    </ul>
                </div>

                <div class="component-card">
                    <h3>🔌 AgentCoreClient</h3>
                    <p><strong>Location:</strong> <code>/agentCoreClient</code></p>
                    <p>Client library for interacting with AgentCore.</p>
                    <ul>
                        <li>Task enqueueing</li>
                        <li>Result polling</li>
                        <li>File-based communication (current)</li>
                        <li>HTTP communication (future)</li>
                    </ul>
                </div>

                <div class="component-card">
                    <h3>💻 PloinkyClient SDK</h3>
                    <p><strong>Location:</strong> <code>/client</code></p>
                    <p>JavaScript SDK for browser and Node.js applications.</p>
                    <ul>
                        <li>Simple API for agent interaction</li>
                        <li>Authentication handling</li>
                        <li>Error management</li>
                        <li>Promise-based interface</li>
                    </ul>
                </div>

                <div class="component-card">
                    <h3>🖥️ CLI Interface</h3>
                    <p><strong>Location:</strong> <code>/cli</code></p>
                    <p>Command-line interface for system administration.</p>
                    <ul>
                        <li>Local development commands</li>
                        <li>Cloud operations</li>
                        <li>Container management</li>
                        <li>Interactive shell</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="data-flow" class="content-section">
            <h2>Data Flow Architecture</h2>
            
            <h3>Current Implementation (File-based)</h3>
            <div class="architecture-diagram">
                <pre>
1. HTTP Request → Cloud Server
   POST /demo/hello { params: ["world"] }
   
2. Cloud Server → Task Orchestrator
   Create task with security context
   
3. Task Orchestrator → AgentCoreTaskExecutor
   Deployment lookup and validation
   
4. AgentCoreTaskExecutor → AgentCoreClient
   Task enqueuing via filesystem
   
5. Filesystem Queue (Write)
   /agents/localhost/demo/.ploinky/queue/tasks/{taskId}
   
6. AgentCore in Container (Poll & Process)
   Read task → Execute → Write result
   
7. Filesystem Queue (Result)
   /agents/localhost/demo/.ploinky/queue/results/{taskId}
   
8. AgentCoreClient → HTTP Response
   Poll result → Return to client
                </pre>
            </div>

            <h3>Future Implementation (HTTP-based)</h3>
            <div class="architecture-diagram">
                <pre>
1. HTTP Request → Cloud Server
   POST /demo/hello { params: ["world"] }
   
2. Cloud Server → Container HTTP
   Direct HTTP call to container port
   
3. Container AgentCore Server
   Process request → Return response
   
4. Cloud Server → HTTP Response
   Forward response to client
                </pre>
            </div>

            <h3>Performance Comparison</h3>
            <table class="performance-table">
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>File-based</th>
                        <th>HTTP-based</th>
                        <th>Improvement</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Latency</td>
                        <td>200-400ms</td>
                        <td>10-50ms</td>
                        <td>~8x faster</td>
                    </tr>
                    <tr>
                        <td>Throughput</td>
                        <td>~100 req/s</td>
                        <td>~1000 req/s</td>
                        <td>10x higher</td>
                    </tr>
                    <tr>
                        <td>Complexity</td>
                        <td>Low</td>
                        <td>Medium</td>
                        <td>-</td>
                    </tr>
                    <tr>
                        <td>Debugging</td>
                        <td>Hard</td>
                        <td>Easy</td>
                        <td>Much better</td>
                    </tr>
                    <tr>
                        <td>Persistence</td>
                        <td>Built-in</td>
                        <td>Requires implementation</td>
                        <td>-</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section id="concurrency" class="content-section">
            <h2>Concurrency & Performance</h2>
            
            <h3>Parallel Task Execution</h3>
            <p>Ploinky supports high-performance parallel task execution through several optimization strategies:</p>
            
            <div class="component-grid">
                <div class="component-card">
                    <h3>🔒 Race Condition Prevention</h3>
                    <ul>
                        <li><strong>Container Port Management:</strong> Port caching with validation</li>
                        <li><strong>Container Creation Locking:</strong> Atomic filesystem operations using mkdir</li>
                        <li><strong>Task Queue Management:</strong> Atomic file operations prevent corruption</li>
                    </ul>
                </div>

                <div class="component-card">
                    <h3>⚡ Performance Optimizations</h3>
                    <ul>
                        <li><strong>Port Caching:</strong> Reduces system calls by 80%</li>
                        <li><strong>Container Reuse:</strong> Persistent containers across task executions</li>
                        <li><strong>Warm Containers:</strong> Eliminate startup overhead</li>
                        <li><strong>Lock-Free Fast Path:</strong> Check cached values before acquiring locks</li>
                    </ul>
                </div>
            </div>

            <h3>Stress Testing Results</h3>
            <table class="performance-table">
                <thead>
                    <tr>
                        <th>Concurrent Tasks</th>
                        <th>Success Rate</th>
                        <th>Avg Lock Wait</th>
                        <th>Port Cache Hit</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>1 (Sequential)</td>
                        <td>100%</td>
                        <td>0ms</td>
                        <td>N/A</td>
                    </tr>
                    <tr>
                        <td>10</td>
                        <td>100%</td>
                        <td>50ms</td>
                        <td>70%</td>
                    </tr>
                    <tr>
                        <td>20</td>
                        <td>>95%</td>
                        <td>200ms</td>
                        <td>85%</td>
                    </tr>
                    <tr>
                        <td>50</td>
                        <td>>90%</td>
                        <td>1200ms</td>
                        <td>87%</td>
                    </tr>
                    <tr>
                        <td>100</td>
                        <td>>85%</td>
                        <td>2500ms</td>
                        <td>90%</td>
                    </tr>
                </tbody>
            </table>

            <h3>Benchmarks</h3>
            <table class="performance-table">
                <thead>
                    <tr>
                        <th>Operation</th>
                        <th>Latency (p50)</th>
                        <th>Latency (p99)</th>
                        <th>Throughput</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Task Submit</td>
                        <td>5ms</td>
                        <td>20ms</td>
                        <td>2000/s</td>
                    </tr>
                    <tr>
                        <td>Task Execute (file)</td>
                        <td>250ms</td>
                        <td>500ms</td>
                        <td>100/s</td>
                    </tr>
                    <tr>
                        <td>Task Execute (HTTP)</td>
                        <td>25ms</td>
                        <td>100ms</td>
                        <td>1000/s</td>
                    </tr>
                    <tr>
                        <td>Container Start</td>
                        <td>2s</td>
                        <td>5s</td>
                        <td>10/s</td>
                    </tr>
                    <tr>
                        <td>Container Port Lookup</td>
                        <td>1ms</td>
                        <td>5ms</td>
                        <td>5000/s</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section id="security" class="content-section">
            <h2>Security Architecture</h2>
            
            <h3>Security Layers</h3>
            <div class="component-grid">
                <div class="component-card">
                    <h3>🔐 Transport Security</h3>
                    <p>HTTPS termination at reverse proxy level for encrypted communication.</p>
                </div>
                <div class="component-card">
                    <h3>🎫 Authentication</h3>
                    <p>API keys and session tokens for user verification.</p>
                </div>
                <div class="component-card">
                    <h3>🛡️ Authorization</h3>
                    <p>Role-based access control (RBAC) for permission management.</p>
                </div>
                <div class="component-card">
                    <h3>📦 Container Isolation</h3>
                    <p>Separate namespaces and cgroups for process isolation.</p>
                </div>
                <div class="component-card">
                    <h3>⚡ Resource Limits</h3>
                    <p>CPU/Memory constraints to prevent resource exhaustion.</p>
                </div>
                <div class="component-card">
                    <h3>📝 Auditing</h3>
                    <p>Comprehensive request/response logging with security context.</p>
                </div>
            </div>

            <h3>Authentication Flow</h3>
            <div class="architecture-diagram">
                <pre>
Client Request
     │
     ▼
Extract Credentials ──────▶ Missing ──────▶ 401 Unauthorized
     │
     │ Present
     ▼
Validate Token ──────────▶ Invalid ──────▶ 401 Unauthorized
     │
     │ Valid
     ▼
Check Permissions ───────▶ Denied ───────▶ 403 Forbidden
     │
     │ Allowed
     ▼
Process Request ─────────▶ Response
                </pre>
            </div>
        </section>

        <section id="deployment" class="content-section">
            <h2>Deployment Architecture</h2>
            
            <h3>Production Deployment with Docker Compose</h3>
            <div class="code-block">
                <code>version: '3.8'
services:
  ploinky:
    image: ploinky/cloud:latest
    ports:
      - "8000:8000"
    volumes:
      - ./data:/data
      - /var/run/docker.sock:/var/run/docker.sock
    environment:
      - NODE_ENV=production
      - WORKERS=auto
    deploy:
      replicas: 3
      restart_policy:
        condition: on-failure</code>
            </div>

            <h3>Horizontal Scaling Architecture</h3>
            <div class="architecture-diagram">
                <pre>
Load Balancer (nginx/haproxy)
      │
      ├──── Node 1 (8 workers)
      ├──── Node 2 (8 workers)
      └──── Node N (8 workers)
            │
            └──── Shared Storage (NFS/GlusterFS)
                </pre>
            </div>

            <h3>Monitoring Stack</h3>
            <div class="architecture-diagram">
                <pre>
Ploinky Metrics ──▶ Prometheus ──▶ Grafana
      │                              │
      └──▶ Logs ──▶ Loki ────────────┘
                </pre>
            </div>
        </section>

        <section id="future" class="content-section">
            <h2>Future Roadmap</h2>
            
            <div class="component-grid">
                <div class="component-card">
                    <h3>📅 Short Term (3 months)</h3>
                    <ul>
                        <li>✅ Complete HTTP-based AgentCore</li>
                        <li>⬜ WebSocket support for real-time</li>
                        <li>⬜ Basic metrics dashboard</li>
                        <li>⬜ Docker Compose import</li>
                    </ul>
                </div>

                <div class="component-card">
                    <h3>📅 Medium Term (6 months)</h3>
                    <ul>
                        <li>⬜ Distributed task queue (Redis)</li>
                        <li>⬜ Multi-node clustering</li>
                        <li>⬜ Agent marketplace</li>
                        <li>⬜ Advanced monitoring</li>
                    </ul>
                </div>

                <div class="component-card">
                    <h3>📅 Long Term (12 months)</h3>
                    <ul>
                        <li>⬜ Kubernetes operator</li>
                        <li>⬜ Service mesh integration</li>
                        <li>⬜ Cloud provider adapters</li>
                        <li>⬜ Enterprise features</li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="content-section">
            <h2>Design Patterns</h2>
            
            <table class="performance-table">
                <thead>
                    <tr>
                        <th>Pattern</th>
                        <th>Implementation</th>
                        <th>Rationale</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Strategy Pattern</strong></td>
                        <td>Task Queue implementations</td>
                        <td>Swap queue backends transparently</td>
                    </tr>
                    <tr>
                        <td><strong>Factory Pattern</strong></td>
                        <td>Container runtime selection</td>
                        <td>Docker/Podman abstraction</td>
                    </tr>
                    <tr>
                        <td><strong>Observer Pattern</strong></td>
                        <td>File system watchers</td>
                        <td>Event-driven task processing</td>
                    </tr>
                    <tr>
                        <td><strong>Singleton Pattern</strong></td>
                        <td>Configuration manager</td>
                        <td>Single source of truth</td>
                    </tr>
                    <tr>
                        <td><strong>Command Pattern</strong></td>
                        <td>Task/Command objects</td>
                        <td>Encapsulate operations</td>
                    </tr>
                    <tr>
                        <td><strong>Proxy Pattern</strong></td>
                        <td>PloinkyClient</td>
                        <td>Remote object access</td>
                    </tr>
                    <tr>
                        <td><strong>Chain of Responsibility</strong></td>
                        <td>Request routing</td>
                        <td>Layered request handling</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <section class="content-section">
            <h2>Conclusion</h2>
            <p>Ploinky represents a pragmatic approach to container orchestration, prioritizing developer experience and operational simplicity. The architecture is designed to evolve from simple file-based communication to sophisticated HTTP-based systems while maintaining backward compatibility and operational stability.</p>
            
            <div class="features">
                <div class="feature-card">
                    <h3>💡 Simplicity</h3>
                    <p>Easy to understand and debug</p>
                </div>
                <div class="feature-card">
                    <h3>🔄 Flexibility</h3>
                    <p>Supports multiple deployment patterns</p>
                </div>
                <div class="feature-card">
                    <h3>✅ Reliability</h3>
                    <p>Fail-safe file-based operations</p>
                </div>
                <div class="feature-card">
                    <h3>⚡ Performance</h3>
                    <p>Efficient resource utilization</p>
                </div>
                <div class="feature-card">
                    <h3>🔌 Extensibility</h3>
                    <p>Plugin architecture for customization</p>
                </div>
                <div class="feature-card">
                    <h3>🚀 Future-Proof</h3>
                    <p>Progressive enhancement path</p>
                </div>
            </div>
            
            <p>This design ensures Ploinky can serve both small deployments requiring minimal overhead and large-scale systems demanding high performance and reliability.</p>
        </section>
    </main>

    <footer class="footer">
        <div class="container">
            <p>&copy; 2024 Ploinky Project. Open Source under MIT License.</p>
        </div>
    </footer>
</body>
</html>