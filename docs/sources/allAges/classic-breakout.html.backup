<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Breakout Game</title>
  <style>
    :root { --bg:#0b0f17; --fg:#e5e7eb; }
    * { box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { height:100%; display:flex; align-items:center; justify-content:center; flex-direction:column; }
    .panel { text-align:center; padding:24px; border-radius:16px; }
    .stats { font-size:20px; font-weight:700; margin-bottom:16px; display:flex; gap:30px; justify-content:center; }
    .stats span { color:#60a5fa; }
    canvas { border:2px solid #1f2937; border-radius:8px; background:#0b1220; cursor:none; }
    .info { margin-top:16px; font-size:14px; opacity:0.8; }
    .controls { margin-top:20px; }
    .controls button { padding:10px 20px; background:#60a5fa; color:#fff; border:none; border-radius:8px; font-weight:700; cursor:pointer; }
    .controls button:active { background:#3b82f6; }
    .game-over { font-size:24px; color:#ef4444; margin-top:16px; font-weight:700; }
    .mobile-controls { display:none; margin-top:20px; gap:10px; }
    .mobile-controls button { padding:20px 30px; background:#1f2937; color:#fff; border:none; border-radius:8px; font-size:24px; font-weight:bold; }
    @media (max-width: 600px) {
      .mobile-controls { display:flex; justify-content:center; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="stats">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
      </div>
      <canvas id="game" width="480" height="320"></canvas>
      <!-- Inspired by classic Breakout arcade game -->
      <!-- Source reference: https://gist.github.com/straker/ff00b4b49669ad3dec890306d348adc4 -->
      <div class="info">Move mouse or touch to control paddle</div>
      <div id="gameOver" class="game-over" style="display:none;">
        <div id="gameOverText">Game Over!</div>
      </div>
      <div class="controls">
        <button onclick="startGame()">New Game</button>
      </div>
      <div class="mobile-controls">
        <button id="leftBtn">←</button>
        <button id="rightBtn">→</button>
      </div>
    </div>
  </div>
  <script>
    // Classic Breakout game implementation
    // Inspired by: https://gist.github.com/straker/ff00b4b49669ad3dec890306d348adc4
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const gameOverEl = document.getElementById('gameOver');
    const gameOverTextEl = document.getElementById('gameOverText');
    
    // Game variables
    let score = 0;
    let lives = 3;
    let gameRunning = false;
    let animationId = null;
    
    // Paddle
    const paddleHeight = 10;
    const paddleWidth = 75;
    let paddleX = (canvas.width - paddleWidth) / 2;
    
    // Ball
    let ballX = canvas.width / 2;
    let ballY = canvas.height - 30;
    let ballDX = 3;
    let ballDY = -3;
    const ballRadius = 8;
    
    // Bricks
    const brickRowCount = 5;
    const brickColumnCount = 8;
    const brickWidth = 50;
    const brickHeight = 20;
    const brickPadding = 5;
    const brickOffsetTop = 30;
    const brickOffsetLeft = 35;
    
    let bricks = [];
    
    const brickColors = ['#ef4444', '#f97316', '#eab308', '#10b981', '#3b82f6'];
    
    function initBricks() {
      bricks = [];
      for (let c = 0; c < brickColumnCount; c++) {
        bricks[c] = [];
        for (let r = 0; r < brickRowCount; r++) {
          bricks[c][r] = { x: 0, y: 0, status: 1, color: brickColors[r] };
        }
      }
    }
    
    function drawBall() {
      ctx.beginPath();
      ctx.arc(ballX, ballY, ballRadius, 0, Math.PI * 2);
      ctx.fillStyle = '#60a5fa';
      ctx.fill();
      ctx.closePath();
    }
    
    function drawPaddle() {
      ctx.beginPath();
      ctx.rect(paddleX, canvas.height - paddleHeight - 10, paddleWidth, paddleHeight);
      ctx.fillStyle = '#10b981';
      ctx.fill();
      ctx.closePath();
    }
    
    function drawBricks() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          if (bricks[c][r].status === 1) {
            const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
            const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
            bricks[c][r].x = brickX;
            bricks[c][r].y = brickY;
            ctx.beginPath();
            ctx.rect(brickX, brickY, brickWidth, brickHeight);
            ctx.fillStyle = bricks[c][r].color;
            ctx.fill();
            ctx.closePath();
          }
        }
      }
    }
    
    function collisionDetection() {
      for (let c = 0; c < brickColumnCount; c++) {
        for (let r = 0; r < brickRowCount; r++) {
          const b = bricks[c][r];
          if (b.status === 1) {
            if (ballX > b.x && ballX < b.x + brickWidth && 
                ballY > b.y && ballY < b.y + brickHeight) {
              ballDY = -ballDY;
              b.status = 0;
              score += (5 - r) * 10; // Higher rows worth more points
              scoreEl.textContent = score;
              
              // Check if all bricks are destroyed
              if (score === calculateMaxScore()) {
                gameWon();
              }
            }
          }
        }
      }
    }
    
    function calculateMaxScore() {
      let maxScore = 0;
      for (let r = 0; r < brickRowCount; r++) {
        maxScore += brickColumnCount * (5 - r) * 10;
      }
      return maxScore;
    }
    
    function draw() {
      if (!gameRunning) return;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawBricks();
      drawBall();
      drawPaddle();
      collisionDetection();
      
      // Ball movement
      ballX += ballDX;
      ballY += ballDY;
      
      // Ball collision with walls
      if (ballX + ballDX > canvas.width - ballRadius || ballX + ballDX < ballRadius) {
        ballDX = -ballDX;
      }
      if (ballY + ballDY < ballRadius) {
        ballDY = -ballDY;
      } else if (ballY + ballDY > canvas.height - ballRadius) {
        // Ball collision with paddle
        if (ballX > paddleX && ballX < paddleX + paddleWidth) {
          ballDY = -ballDY;
          // Add some variation to ball angle based on where it hits the paddle
          const hitPos = (ballX - paddleX) / paddleWidth;
          ballDX = 6 * (hitPos - 0.5);
        } else {
          // Ball missed paddle
          lives--;
          livesEl.textContent = lives;
          if (lives === 0) {
            gameOver();
          } else {
            resetBall();
          }
        }
      }
      
      animationId = requestAnimationFrame(draw);
    }
    
    function resetBall() {
      ballX = canvas.width / 2;
      ballY = canvas.height - 30;
      ballDX = 3;
      ballDY = -3;
      paddleX = (canvas.width - paddleWidth) / 2;
    }
    
    function gameOver() {
      gameRunning = false;
      gameOverTextEl.textContent = 'Game Over! Final Score: ' + score;
      gameOverEl.style.display = 'block';
      cancelAnimationFrame(animationId);
    }
    
    function gameWon() {
      gameRunning = false;
      gameOverTextEl.textContent = 'You Win! Score: ' + score;
      gameOverEl.style.display = 'block';
      cancelAnimationFrame(animationId);
    }
    
    function startGame() {
      score = 0;
      lives = 3;
      scoreEl.textContent = score;
      livesEl.textContent = lives;
      gameOverEl.style.display = 'none';
      initBricks();
      resetBall();
      gameRunning = true;
      draw();
    }
    
    // Mouse control
    canvas.addEventListener('mousemove', (e) => {
      if (!gameRunning) return;
      const relativeX = e.clientX - canvas.offsetLeft;
      if (relativeX > 0 && relativeX < canvas.width) {
        paddleX = relativeX - paddleWidth / 2;
        if (paddleX < 0) paddleX = 0;
        if (paddleX + paddleWidth > canvas.width) {
          paddleX = canvas.width - paddleWidth;
        }
      }
    });
    
    // Touch control
    canvas.addEventListener('touchmove', (e) => {
      if (!gameRunning) return;
      e.preventDefault();
      const touch = e.touches[0];
      const relativeX = touch.clientX - canvas.offsetLeft;
      if (relativeX > 0 && relativeX < canvas.width) {
        paddleX = relativeX - paddleWidth / 2;
        if (paddleX < 0) paddleX = 0;
        if (paddleX + paddleWidth > canvas.width) {
          paddleX = canvas.width - paddleWidth;
        }
      }
    });
    
    // Mobile button controls
    let leftPressed = false;
    let rightPressed = false;
    
    document.getElementById('leftBtn')?.addEventListener('touchstart', () => {
      leftPressed = true;
    });
    document.getElementById('leftBtn')?.addEventListener('touchend', () => {
      leftPressed = false;
    });
    document.getElementById('rightBtn')?.addEventListener('touchstart', () => {
      rightPressed = true;
    });
    document.getElementById('rightBtn')?.addEventListener('touchend', () => {
      rightPressed = false;
    });
    
    setInterval(() => {
      if (!gameRunning) return;
      if (leftPressed && paddleX > 0) paddleX -= 7;
      if (rightPressed && paddleX < canvas.width - paddleWidth) paddleX += 7;
    }, 16);
    
    // Initialize game
    initBricks();
  </script>
</body>
</html>