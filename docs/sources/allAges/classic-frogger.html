<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover" />
  <title>Frogger Game</title>
  <style>
    :root { 
      --bg: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --fg: #ffffff;
      --glass-bg: rgba(255, 255, 255, 0.1);
      --glass-border: rgba(255, 255, 255, 0.2);
      --glass-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
      --frog-primary: #10b981;
      --frog-glow: rgba(16, 185, 129, 0.6);
      --water: linear-gradient(45deg, #1e40af, #3b82f6);
      --road: linear-gradient(45deg, #374151, #4b5563);
      --safe: linear-gradient(45deg, #059669, #10b981);
      --goal: linear-gradient(45deg, #fbbf24, #f59e0b);
      --car-red: linear-gradient(45deg, #ef4444, #dc2626);
      --car-orange: linear-gradient(45deg, #f97316, #ea580c);
      --log: linear-gradient(45deg, #8b4513, #a0522d);
    }
    
    * { 
      box-sizing: border-box; 
      -webkit-tap-highlight-color: transparent;
      margin: 0;
      padding: 0;
    }
    
    html, body { 
      height: 100vh;
      height: 100dvh;
      margin: 0; 
      background: var(--bg);
      color: var(--fg); 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      overflow: hidden;
      position: fixed;
      width: 100%;
    }
    
    .container { 
      height: 100vh;
      height: 100dvh;
      display: flex; 
      align-items: center; 
      justify-content: center; 
      flex-direction: column;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
      position: relative;
    }
    
    .game-panel { 
      text-align: center; 
      padding: clamp(16px, 4vw, 32px);
      border-radius: 24px;
      background: var(--glass-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      box-shadow: var(--glass-shadow);
      max-width: 95vw;
      max-height: 95vh;
      position: relative;
    }
    
    .stats { 
      font-size: clamp(16px, 4vw, 20px);
      font-weight: 700; 
      margin-bottom: 16px; 
      display: flex; 
      gap: clamp(20px, 5vw, 30px);
      justify-content: center;
      flex-wrap: wrap;
    }
    
    .stat-item {
      background: var(--glass-bg);
      padding: 8px 16px;
      border-radius: 16px;
      border: 1px solid var(--glass-border);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    
    .stats span { 
      color: #60a5fa;
      text-shadow: 0 0 10px rgba(96, 165, 250, 0.5);
    }
    
    #gameCanvas { 
      border: 2px solid var(--glass-border);
      border-radius: 16px;
      background: #0b1220;
      max-width: 100%;
      max-height: 60vh;
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 2px 4px rgba(255, 255, 255, 0.1);
      display: block;
      margin: 0 auto;
    }
    
    .info { 
      margin-top: 16px; 
      font-size: clamp(12px, 3vw, 14px);
      opacity: 0.9;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }
    
    .controls { 
      margin-top: 20px; 
      display: grid; 
      grid-template-columns: repeat(3, 1fr);
      gap: clamp(8px, 2vw, 12px);
      max-width: 200px;
      margin-left: auto;
      margin-right: auto;
    }
    
    .control-btn { 
      padding: clamp(12px, 3vw, 16px);
      background: var(--glass-bg);
      color: var(--fg);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      font-size: clamp(16px, 4vw, 20px);
      font-weight: bold;
      cursor: pointer;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      transition: all 0.2s ease;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      aspect-ratio: 1;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
    }
    
    .control-btn:active, .control-btn.pressed { 
      background: var(--glass-border);
      transform: scale(0.95);
      box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.3);
    }
    
    .control-btn:hover {
      background: var(--glass-border);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
    }
    
    .empty { 
      visibility: hidden; 
    }
    
    .restart-btn { 
      margin-top: 16px; 
      padding: 12px 24px; 
      background: linear-gradient(45deg, #60a5fa, #3b82f6);
      color: var(--fg);
      border: none; 
      border-radius: 16px;
      font-weight: 700; 
      cursor: pointer;
      font-size: clamp(14px, 3vw, 16px);
      box-shadow: 0 4px 16px rgba(96, 165, 250, 0.3);
      transition: all 0.2s ease;
    }
    
    .restart-btn:active {
      transform: scale(0.95);
    }
    
    .restart-btn:hover {
      box-shadow: 0 6px 20px rgba(96, 165, 250, 0.4);
    }
    
    .game-over { 
      font-size: clamp(18px, 4vw, 24px);
      color: #ef4444; 
      margin-top: 16px; 
      font-weight: 700;
      text-shadow: 0 0 10px rgba(239, 68, 68, 0.5);
      animation: pulse 1.5s ease-in-out infinite alternate;
    }
    
    @keyframes pulse {
      from { opacity: 0.8; }
      to { opacity: 1; }
    }
    
    .particle {
      position: absolute;
      pointer-events: none;
      border-radius: 50%;
      animation: particleFloat 2s ease-out forwards;
    }
    
    @keyframes particleFloat {
      0% {
        transform: translateY(0) scale(1);
        opacity: 1;
      }
      100% {
        transform: translateY(-100px) scale(0);
        opacity: 0;
      }
    }
    
    /* Responsive adjustments */
    @media (max-width: 480px) {
      .game-panel {
        padding: 16px;
        margin: 8px;
      }
      
      .stats {
        gap: 15px;
        font-size: 14px;
      }
      
      .controls {
        max-width: 180px;
        gap: 8px;
      }
    }
    
    @media (orientation: landscape) and (max-height: 500px) {
      .container {
        flex-direction: row;
        gap: 20px;
      }
      
      .stats {
        font-size: 14px;
        gap: 15px;
      }
      
      #gameCanvas {
        max-height: 70vh;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="game-panel">
      <div class="stats">
        <div class="stat-item">Score: <span id="score">0</span></div>
        <div class="stat-item">Lives: <span id="lives">3</span></div>
        <div class="stat-item">Level: <span id="level">1</span></div>
      </div>
      <canvas id="gameCanvas" width="480" height="480"></canvas>
      <div class="info">Use arrow keys, swipe, or tap buttons to move the frog</div>
      <div class="controls">
        <div class="empty"></div>
        <button class="control-btn" id="up">↑</button>
        <div class="empty"></div>
        <button class="control-btn" id="left">←</button>
        <button class="control-btn" id="down">↓</button>
        <button class="control-btn" id="right">→</button>
      </div>
      <div id="gameOver" class="game-over" style="display:none;">
        Game Over!
        <br>
        <button class="restart-btn" onclick="restartGame()">Restart Game</button>
      </div>
    </div>
  </div>
  
  <script>
    // Enhanced Frogger game with modern features
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');
    const gameOverEl = document.getElementById('gameOver');
    
    // Responsive canvas sizing
    function resizeCanvas() {
      const container = canvas.parentElement;
      const maxWidth = Math.min(container.clientWidth - 40, 480);
      const maxHeight = Math.min(container.clientHeight * 0.6, 480);
      const size = Math.min(maxWidth, maxHeight);
      
      canvas.width = size;
      canvas.height = size;
      canvas.style.width = size + 'px';
      canvas.style.height = size + 'px';
    }
    
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();
    
    const gridSize = canvas.width / 12;
    const rows = canvas.height / gridSize;
    const cols = canvas.width / gridSize;
    
    let score = 0;
    let lives = 3;
    let level = 1;
    let gameRunning = true;
    let particles = [];
    
    // Haptic feedback function
    function vibrate(pattern = 50) {
      if (navigator.vibrate) {
        navigator.vibrate(pattern);
      }
    }
    
    // Particle system
    function createParticles(x, y, color, count = 5) {
      for (let i = 0; i < count; i++) {
        particles.push({
          x: x + (Math.random() - 0.5) * 20,
          y: y + (Math.random() - 0.5) * 20,
          vx: (Math.random() - 0.5) * 4,
          vy: -Math.random() * 3 - 1,
          color: color,
          life: 1,
          decay: 0.02 + Math.random() * 0.02
        });
      }
    }
    
    function updateParticles() {
      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= p.decay;
        return p.life > 0;
      });
    }
    
    function drawParticles() {
      particles.forEach(p => {
        ctx.save();
        ctx.globalAlpha = p.life;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });
    }
    
    // Frog object
    let frog = {
      x: Math.floor(cols / 2) * gridSize,
      y: (rows - 1) * gridSize,
      size: gridSize - 4,
      animation: 0
    };
    
    let vehicles = [];
    let logs = [];
    
    // Enhanced lane configuration with gradients
    const lanes = [
      { y: 11, type: 'safe', speed: 0 },
      { y: 10, type: 'road', speed: 1, dir: 1 },
      { y: 9, type: 'road', speed: 1.5, dir: -1 },
      { y: 8, type: 'road', speed: 1, dir: 1 },
      { y: 7, type: 'road', speed: 2, dir: -1 },
      { y: 6, type: 'safe', speed: 0 },
      { y: 5, type: 'water', speed: 1, dir: 1 },
      { y: 4, type: 'water', speed: 1.5, dir: -1 },
      { y: 3, type: 'water', speed: 1, dir: 1 },
      { y: 2, type: 'water', speed: 1.2, dir: -1 },
      { y: 1, type: 'water', speed: 1.5, dir: 1 },
      { y: 0, type: 'goal', speed: 0 }
    ];
    
    function initLevel() {
      vehicles = [];
      logs = [];
      
      lanes.forEach(lane => {
        if (lane.type === 'road') {
          for (let i = 0; i < 3; i++) {
            vehicles.push({
              x: i * (canvas.width / 3) + Math.random() * 60,
              y: lane.y * gridSize,
              width: gridSize * 1.5,
              height: gridSize - 8,
              speed: lane.speed * lane.dir * (1 + level * 0.15),
              color: lane.dir > 0 ? '#ef4444' : '#f97316',
              glow: lane.dir > 0 ? 'rgba(239, 68, 68, 0.5)' : 'rgba(249, 115, 22, 0.5)'
            });
          }
        } else if (lane.type === 'water') {
          for (let i = 0; i < 2; i++) {
            logs.push({
              x: i * (canvas.width / 2) + Math.random() * 80,
              y: lane.y * gridSize,
              width: gridSize * (2.5 + Math.random()),
              height: gridSize - 8,
              speed: lane.speed * lane.dir * (1 + level * 0.1),
              color: '#8b4513'
            });
          }
        }
      });
    }
    
    function drawFrog() {
      ctx.save();
      
      // Glow effect
      ctx.shadowColor = 'rgba(16, 185, 129, 0.6)';
      ctx.shadowBlur = 15;
      
      // Main body with gradient
      const gradient = ctx.createRadialGradient(
        frog.x + frog.size/2, frog.y + frog.size/2, 0,
        frog.x + frog.size/2, frog.y + frog.size/2, frog.size/2
      );
      gradient.addColorStop(0, '#34d399');
      gradient.addColorStop(1, '#10b981');
      
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.roundRect(frog.x + 2, frog.y + 2, frog.size, frog.size, frog.size/4);
      ctx.fill();
      
      // Eyes with glow
      ctx.fillStyle = '#ffffff';
      ctx.shadowBlur = 8;
      ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';
      ctx.beginPath();
      ctx.arc(frog.x + frog.size * 0.3, frog.y + frog.size * 0.3, 3, 0, Math.PI * 2);
      ctx.arc(frog.x + frog.size * 0.7, frog.y + frog.size * 0.3, 3, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
    
    function drawLanes() {
      lanes.forEach(lane => {
        const y = lane.y * gridSize;
        let gradient;
        
        if (lane.type === 'safe') {
          gradient = ctx.createLinearGradient(0, y, 0, y + gridSize);
          gradient.addColorStop(0, '#059669');
          gradient.addColorStop(1, '#047857');
          ctx.fillStyle = gradient;
        } else if (lane.type === 'water') {
          gradient = ctx.createLinearGradient(0, y, canvas.width, y);
          gradient.addColorStop(0, '#1e40af');
          gradient.addColorStop(0.5, '#3b82f6');
          gradient.addColorStop(1, '#1e40af');
          ctx.fillStyle = gradient;
        } else if (lane.type === 'road') {
          gradient = ctx.createLinearGradient(0, y, 0, y + gridSize);
          gradient.addColorStop(0, '#4b5563');
          gradient.addColorStop(1, '#374151');
          ctx.fillStyle = gradient;
        } else if (lane.type === 'goal') {
          gradient = ctx.createLinearGradient(0, y, canvas.width, y);
          gradient.addColorStop(0, '#fbbf24');
          gradient.addColorStop(0.5, '#f59e0b');
          gradient.addColorStop(1, '#fbbf24');
          ctx.fillStyle = gradient;
        }
        
        ctx.fillRect(0, y, canvas.width, gridSize);
        
        // Lane line effects
        if (lane.type === 'road') {
          ctx.save();
          ctx.strokeStyle = '#fbbf24';
          ctx.lineWidth = 2;
          ctx.setLineDash([15, 10]);
          ctx.shadowColor = 'rgba(251, 191, 36, 0.5)';
          ctx.shadowBlur = 3;
          ctx.beginPath();
          ctx.moveTo(0, y + gridSize / 2);
          ctx.lineTo(canvas.width, y + gridSize / 2);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();
        }
      });
    }
    
    function drawVehicles() {
      vehicles.forEach(vehicle => {
        ctx.save();
        
        // Glow effect
        ctx.shadowColor = vehicle.glow;
        ctx.shadowBlur = 10;
        
        // Vehicle gradient
        const gradient = ctx.createLinearGradient(vehicle.x, vehicle.y, vehicle.x + vehicle.width, vehicle.y);
        gradient.addColorStop(0, vehicle.color);
        gradient.addColorStop(0.5, vehicle.color + 'dd');
        gradient.addColorStop(1, vehicle.color);
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.roundRect(vehicle.x, vehicle.y + 4, vehicle.width, vehicle.height, 4);
        ctx.fill();
        
        // Headlights/taillights
        ctx.fillStyle = vehicle.speed > 0 ? '#ffffff' : '#ff0000';
        ctx.shadowColor = vehicle.speed > 0 ? 'rgba(255, 255, 255, 0.8)' : 'rgba(255, 0, 0, 0.8)';
        ctx.shadowBlur = 5;
        const lightX = vehicle.speed > 0 ? vehicle.x + vehicle.width - 3 : vehicle.x + 3;
        ctx.fillRect(lightX, vehicle.y + 8, 3, vehicle.height - 8);
        
        ctx.restore();
      });
    }
    
    function drawLogs() {
      logs.forEach(log => {
        ctx.save();
        
        // Log gradient
        const gradient = ctx.createLinearGradient(log.x, log.y, log.x, log.y + log.height);
        gradient.addColorStop(0, '#a0522d');
        gradient.addColorStop(0.5, '#8b4513');
        gradient.addColorStop(1, '#654321');
        
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.roundRect(log.x, log.y + 4, log.width, log.height, log.height/4);
        ctx.fill();
        
        // Log texture lines
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        for (let i = 1; i < 3; i++) {
          const y = log.y + 4 + (log.height * i / 3);
          ctx.beginPath();
          ctx.moveTo(log.x, y);
          ctx.lineTo(log.x + log.width, y);
          ctx.stroke();
        }
        
        ctx.restore();
      });
    }
    
    function updateObjects() {
      // Update vehicles
      vehicles.forEach(vehicle => {
        vehicle.x += vehicle.speed;
        if (vehicle.speed > 0 && vehicle.x > canvas.width) {
          vehicle.x = -vehicle.width;
        } else if (vehicle.speed < 0 && vehicle.x < -vehicle.width) {
          vehicle.x = canvas.width;
        }
      });
      
      // Update logs
      logs.forEach(log => {
        log.x += log.speed;
        if (log.speed > 0 && log.x > canvas.width) {
          log.x = -log.width;
        } else if (log.speed < 0 && log.x < -log.width) {
          log.x = canvas.width;
        }
      });
    }
    
    function checkCollisions() {
      const frogRow = Math.floor(frog.y / gridSize);
      const currentLane = lanes.find(l => l.y === frogRow);
      
      if (!currentLane) return;
      
      // Check vehicle collisions
      if (currentLane.type === 'road') {
        for (let vehicle of vehicles) {
          if (frog.x < vehicle.x + vehicle.width &&
              frog.x + frog.size > vehicle.x &&
              frog.y < vehicle.y + vehicle.height &&
              frog.y + frog.size > vehicle.y) {
            createParticles(frog.x + frog.size/2, frog.y + frog.size/2, '#ef4444', 8);
            vibrate([100, 50, 100]);
            loseLife();
            return;
          }
        }
      }
      
      // Check water - need to be on a log
      if (currentLane.type === 'water') {
        let onLog = false;
        for (let log of logs) {
          if (frog.x + 10 >= log.x &&
              frog.x + frog.size - 10 <= log.x + log.width &&
              frog.y >= log.y - 5 &&
              frog.y <= log.y + log.height + 5) {
            onLog = true;
            frog.x += log.speed;
            break;
          }
        }
        if (!onLog) {
          createParticles(frog.x + frog.size/2, frog.y + frog.size/2, '#3b82f6', 6);
          vibrate([100, 50, 100]);
          loseLife();
          return;
        }
      }
      
      // Check if reached goal
      if (currentLane.type === 'goal') {
        score += 100 * level;
        scoreEl.textContent = score;
        level++;
        levelEl.textContent = level;
        createParticles(frog.x + frog.size/2, frog.y + frog.size/2, '#fbbf24', 10);
        vibrate([50, 50, 50]);
        resetFrog();
        initLevel();
      }
      
      // Check boundaries
      if (frog.x < 0 || frog.x > canvas.width - gridSize) {
        loseLife();
      }
    }
    
    function loseLife() {
      lives--;
      livesEl.textContent = lives;
      if (lives <= 0) {
        gameOver();
      } else {
        resetFrog();
      }
    }
    
    function resetFrog() {
      frog.x = Math.floor(cols / 2) * gridSize;
      frog.y = (rows - 1) * gridSize;
    }
    
    function gameOver() {
      gameRunning = false;
      gameOverEl.style.display = 'block';
      vibrate([200, 100, 200, 100, 200]);
    }
    
    function restartGame() {
      score = 0;
      lives = 3;
      level = 1;
      scoreEl.textContent = score;
      livesEl.textContent = lives;
      levelEl.textContent = level;
      gameOverEl.style.display = 'none';
      resetFrog();
      initLevel();
      gameRunning = true;
      particles = [];
      gameLoop();
    }
    
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Background gradient
      const bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      bgGradient.addColorStop(0, '#1e293b');
      bgGradient.addColorStop(1, '#0f172a');
      ctx.fillStyle = bgGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      drawLanes();
      drawLogs();
      drawVehicles();
      drawFrog();
      updateParticles();
      drawParticles();
    }
    
    function gameLoop() {
      if (!gameRunning) return;
      
      updateObjects();
      checkCollisions();
      draw();
      
      requestAnimationFrame(gameLoop);
    }
    
    // Enhanced controls with haptic feedback
    function moveFrog(dx, dy) {
      if (!gameRunning) return;
      
      const newX = frog.x + dx * gridSize;
      const newY = frog.y + dy * gridSize;
      
      if (newX >= 0 && newX <= canvas.width - gridSize &&
          newY >= 0 && newY <= canvas.height - gridSize) {
        frog.x = newX;
        frog.y = newY;
        
        vibrate(30);
        
        // Add points for moving forward
        if (dy < 0) {
          score += 10;
          scoreEl.textContent = score;
          createParticles(frog.x + frog.size/2, frog.y + frog.size/2, '#10b981', 3);
        }
      }
    }
    
    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp') { e.preventDefault(); moveFrog(0, -1); }
      if (e.key === 'ArrowDown') { e.preventDefault(); moveFrog(0, 1); }
      if (e.key === 'ArrowLeft') { e.preventDefault(); moveFrog(-1, 0); }
      if (e.key === 'ArrowRight') { e.preventDefault(); moveFrog(1, 0); }
    });
    
    // Button controls with visual feedback
    function setupButton(id, dx, dy) {
      const btn = document.getElementById(id);
      if (btn) {
        btn.addEventListener('click', () => moveFrog(dx, dy));
        btn.addEventListener('touchstart', (e) => {
          e.preventDefault();
          btn.classList.add('pressed');
          moveFrog(dx, dy);
        });
        btn.addEventListener('touchend', (e) => {
          e.preventDefault();
          btn.classList.remove('pressed');
        });
      }
    }
    
    setupButton('up', 0, -1);
    setupButton('down', 0, 1);
    setupButton('left', -1, 0);
    setupButton('right', 1, 0);
    
    // Touch/swipe controls
    let touchStartX, touchStartY;
    
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      touchStartX = touch.clientX - rect.left;
      touchStartY = touch.clientY - rect.top;
    });
    
    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      if (!touchStartX || !touchStartY) return;
      
      const touch = e.changedTouches[0];
      const rect = canvas.getBoundingClientRect();
      const touchEndX = touch.clientX - rect.left;
      const touchEndY = touch.clientY - rect.top;
      
      const deltaX = touchEndX - touchStartX;
      const deltaY = touchEndY - touchStartY;
      const minSwipeDistance = 30;
      
      if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > minSwipeDistance) {
        moveFrog(deltaX > 0 ? 1 : -1, 0);
      } else if (Math.abs(deltaY) > minSwipeDistance) {
        moveFrog(0, deltaY > 0 ? 1 : -1);
      }
      
      touchStartX = touchStartY = null;
    });
    
    // Initialize and start game
    initLevel();
    gameLoop();
  </script>
</body>
</html>