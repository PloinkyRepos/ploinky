<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Goal Kick: Street League</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <style>
    :root{
      --bg-1:#0b1023;
      --bg-2:#0a2238;
      --ui:#0ea5e9;
      --ui-2:#22c55e;
      --accent:#f59e0b;
      --danger:#ef4444;
      --white:#ffffff;
      --shadow:rgba(0,0,0,.35);
      --glass:rgba(255,255,255,.12);
      --glass-2:rgba(255,255,255,.08);
      --field:#116530;
      --field-2:#0f5a2b;
      --line:rgba(255,255,255,.45);
    }
    *{box-sizing:border-box; margin:0; padding:0; -webkit-tap-highlight-color:transparent; touch-action:none; user-select:none}
    html,body{width:100%;height:100%;overflow:hidden;overscroll-behavior:none;background:radial-gradient(1200px 900px at 20% 10%,var(--bg-1),var(--bg-2))}
    body{font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Ubuntu,"Helvetica Neue",Arial;color:var(--white);padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left)}
    .game{position:relative; width:100%; height:100%; display:flex; align-items:center; justify-content:center}
    canvas{width:100%;height:100%;display:block;cursor:crosshair}

    /* HUD */
    .hud{
      position:fixed; z-index:10; top:calc(8px + env(safe-area-inset-top));
      left:calc(10px + env(safe-area-inset-left)); right:calc(10px + env(safe-area-inset-right));
      display:grid; grid-template-columns:1fr auto auto auto; gap:8px; align-items:center
    }
    .chip{
      display:flex; align-items:center; gap:8px; padding:10px 14px;
      border-radius:999px; background:linear-gradient(135deg,var(--glass),var(--glass-2));
      box-shadow:0 10px 24px var(--shadow); backdrop-filter:blur(10px);
      font-weight:700; font-size:clamp(.8rem,3.5vw,1rem)
    }
    .chip strong{color:var(--ui); letter-spacing:.5px}
    .chip .val{font-variant-numeric:tabular-nums}
    .btn{cursor:pointer; transition:transform .12s ease, box-shadow .12s ease}
    @media(hover:hover){
      .btn:hover{transform:translateY(-2px); box-shadow:0 14px 30px var(--shadow)}
    }
    .btn:active{transform:scale(.96)}
    .chip.badge{background:linear-gradient(135deg,rgba(34,197,94,.25),rgba(14,165,233,.25)); color:#e8faff}
    .chip.warn{background:linear-gradient(135deg,rgba(245,158,11,.25),rgba(14,165,233,.2))}
    .action{background:linear-gradient(135deg,#111827,#0b1220); border:1px solid rgba(255,255,255,.08)}
    .icon{width:22px;height:22px;display:inline-grid;place-items:center}

    /* Instructions & Power */
    .instructions{
      position:fixed; z-index:8; bottom:calc(18px + env(safe-area-inset-bottom));
      left:50%; transform:translateX(-50%);
      background:linear-gradient(135deg,var(--glass),var(--glass-2));
      backdrop-filter:blur(8px); padding:10px 16px; border-radius:999px;
      font-weight:700; font-size:clamp(.85rem,3.6vw,1rem); letter-spacing:.2px;
      color:#d9f0ff; box-shadow:0 8px 20px var(--shadow); animation:hint 2s infinite
    }
    @keyframes hint{0%,100%{transform:translateX(-50%) scale(1)}50%{transform:translateX(-50%) scale(1.05)}}

    .power{
      position:fixed; z-index:9; bottom:calc(70px + env(safe-area-inset-bottom)); left:50%; transform:translateX(-50%);
      width:min(60vw,280px); height:18px; background:rgba(255,255,255,.12); border-radius:999px; overflow:hidden; display:none; box-shadow:0 6px 16px var(--shadow)
    }
    .power-bar{height:100%; width:0%; background:linear-gradient(90deg,#22c55e,#f59e0b,#ef4444)}

    /* Overlays */
    .overlay{
      position:fixed; inset:0; display:none; place-items:center; z-index:20; background:linear-gradient(180deg,rgba(2,6,23,.7),rgba(2,6,23,.85))
    }
    .panel{
      width:min(92vw,720px); background:linear-gradient(135deg,rgba(16,24,40,.75),rgba(18,28,48,.85));
      border:1px solid rgba(255,255,255,.08); border-radius:18px; padding:20px; box-shadow:0 20px 60px var(--shadow); color:#eaf4ff
    }
    .title{
      font-weight:900; letter-spacing:.5px; font-size:clamp(1.4rem,6vw,2rem); margin-bottom:10px; color:#a5f3fc
    }
    .subtitle{opacity:.85; margin-bottom:16px}
    .row{display:flex; flex-wrap:wrap; gap:10px; align-items:center; margin:12px 0}
    .tag{
      padding:10px 14px; border-radius:12px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.1); cursor:pointer; font-weight:700
    }
    .tag.active{background:linear-gradient(135deg,rgba(14,165,233,.3),rgba(34,197,94,.25)); border-color:rgba(14,165,233,.4)}
    .cta{
      width:100%; display:grid; grid-auto-flow:column; gap:10px; margin-top:10px
    }
    .btn-lg{
      padding:14px 16px; border-radius:12px; border:1px solid rgba(255,255,255,.1); background:linear-gradient(135deg,#0b1220,#0f172a); color:#d9f0ff; font-weight:900; letter-spacing:.6px; cursor:pointer; text-align:center
    }
    .btn-lg.primary{background:linear-gradient(135deg,#0ea5e9,#2563eb)}
    .btn-lg.danger{background:linear-gradient(135deg,#ef4444,#b91c1c)}
    .grid{display:grid; gap:10px}

    /* Celebration emoji pop */
    .celebrate{
      position:fixed; z-index:30; top:50%; left:50%; transform:translate(-50%,-50%) scale(0); font-size:clamp(2.5rem,12vw,5rem); pointer-events:none; animation:pop 1s ease-out
    }
    @keyframes pop{0%{transform:translate(-50%,-50%) scale(0) rotate(0)}50%{transform:translate(-50%,-50%) scale(1.4) rotate(15deg)}100%{transform:translate(-50%,-50%) scale(0); opacity:0}}

    /* Wind flag */
    .flag{
      display:flex; align-items:center; gap:6px
    }
    .arrow{
      width:0;height:0;border-top:6px solid transparent;border-bottom:6px solid transparent;border-left:12px solid var(--ui); filter:drop-shadow(0 2px 6px rgba(14,165,233,.5))
    }
    .flag-txt{font-weight:800; color:#a5f3fc}

    /* Safe for ultra tall/short screens */
    @media (max-height:520px){
      .instructions{display:none}
    }
  </style>
</head>
<body>
  <div class="game">
    <div class="hud">
      <div class="chip badge"><span class="icon">‚öΩ</span><strong>GOALS</strong><span class="val" id="goals">0</span></div>
      <div class="chip warn"><span class="icon">‚è±Ô∏è</span><strong>TIME</strong><span class="val" id="time">10:00</span></div>
      <div class="chip"><div class="flag"><div id="windArrow" class="arrow"></div><span class="flag-txt" id="windTxt">0</span></div></div>
      <div class="chip action btn" id="pauseBtn"><span class="icon">‚è∏Ô∏è</span><span>PAUSE</span></div>
    </div>

    <canvas id="game"></canvas>

    <div class="instructions" id="hint">Drag to aim. Release to shoot. Curve your shot by drawing a slight arc!</div>
    <div class="power" id="power"><div class="power-bar" id="powerBar"></div></div>

    <!-- Start -->
    <div class="overlay" id="menu">
      <div class="panel grid">
        <div class="title">Goal Kick: Street League</div>
        <div class="subtitle">Blue steel vibes. Neon nights. Bend it past the keeper and chase a high score.</div>
        <div class="row">
          <div>Select match length</div>
          <div class="row" id="lengthRow">
            <div class="tag active" data-min="10">10 minutes</div>
            <div class="tag" data-min="12">12 minutes</div>
            <div class="tag" data-min="15">15 minutes</div>
          </div>
        </div>
        <div class="row">
          <div>Difficulty</div>
          <div class="row" id="difficultyRow">
            <div class="tag active" data-diff="0">Rookie</div>
            <div class="tag" data-diff="1">Pro</div>
            <div class="tag" data-diff="2">Legend</div>
          </div>
        </div>
        <div class="cta">
          <div class="btn-lg" id="muteBtn">üîä Sound On</div>
          <div class="btn-lg primary" id="startBtn">Kickoff ‚ñ∂</div>
        </div>
        <div class="row" style="justify-content:space-between; opacity:.85">
          <div>Best: <span id="bestScore">0</span></div>
          <div>Tip: Swipe with a curve to add spin. Wind changes. Targets = bonus time.</div>
        </div>
      </div>
    </div>

    <!-- Pause -->
    <div class="overlay" id="pause">
      <div class="panel grid">
        <div class="title">Paused</div>
        <div class="row" style="gap:12px">
          <div class="btn-lg primary" id="resumeBtn">Resume</div>
          <div class="btn-lg" id="restartBtn">Restart Match</div>
          <div class="btn-lg danger" id="quitBtn">Quit to Menu</div>
        </div>
      </div>
    </div>

    <!-- Game Over -->
    <div class="overlay" id="over">
      <div class="panel grid">
        <div class="title">Full Time</div>
        <div class="row" style="flex-direction:column; gap:6px">
          <div>Goals: <strong id="finalGoals">0</strong></div>
          <div>Best: <strong id="finalBest">0</strong></div>
        </div>
        <div class="row">
          <div class="btn-lg primary" id="againBtn">Play Again</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    ;(()=>{
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      // HUD/UI
      const goalsEl = document.getElementById('goals');
      const timeEl = document.getElementById('time');
      const windTxt = document.getElementById('windTxt');
      const windArrow = document.getElementById('windArrow');
      const hint = document.getElementById('hint');
      const powerBox = document.getElementById('power');
      const powerBar = document.getElementById('powerBar');
      const pauseBtn = document.getElementById('pauseBtn');

      // Overlays
      const menu = document.getElementById('menu');
      const pause = document.getElementById('pause');
      const over = document.getElementById('over');

      const lengthRow = document.getElementById('lengthRow');
      const difficultyRow = document.getElementById('difficultyRow');
      const startBtn = document.getElementById('startBtn');
      const muteBtn = document.getElementById('muteBtn');
      const resumeBtn = document.getElementById('resumeBtn');
      const restartBtn = document.getElementById('restartBtn');
      const quitBtn = document.getElementById('quitBtn');
      const againBtn = document.getElementById('againBtn');
      const bestScoreEl = document.getElementById('bestScore');
      const finalGoalsEl = document.getElementById('finalGoals');
      const finalBestEl = document.getElementById('finalBest');

      // Device pixels and logical size
      let DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio||1));
      let W = 0, H = 0;

      // Game state
      let state = 'menu'; // menu, ready, aiming, kicked, scored, missed, paused, over
      let goals = 0;
      let best = parseInt(localStorage.getItem('gk_best')||'0',10);
      bestScoreEl.textContent = best;
      let timeLeft = 600; // seconds
      let selectedMinutes = 10;
      let difficulty = 0; // 0 rookie, 1 pro, 2 legend
      let lastTime = performance.now();

      // Audio
      const audio = {
        ctx:null,
        enabled:true,
        init(){
          if(this.ctx) return;
          try{
            this.ctx = new (window.AudioContext||window.webkitAudioContext)();
          }catch(e){ this.enabled=false; }
        },
        beep(freq=600,time=0.06,type='sine',gain=0.04){
          if(!this.enabled || !this.ctx) return;
          const o = this.ctx.createOscillator();
          const g = this.ctx.createGain();
          o.type = type; o.frequency.value = freq;
          g.gain.value = gain;
          o.connect(g); g.connect(this.ctx.destination);
          o.start();
          o.stop(this.ctx.currentTime + time);
        },
        kick(){ this.beep(140,0.07,'triangle',0.06) },
        save(){ this.beep(220,0.15,'square',0.05) },
        goal(){ this.beep(880,0.1,'sine',0.06); setTimeout(()=>this.beep(660,0.12,'sine',0.05),90) }
      };

      // Entities
      const ball = {
        x:0,y:0,vx:0,vy:0, r:12,
        spin:0, // -1..1
        trail:[],
        reset(){
          this.x = W*0.5; this.y = H*0.78; this.vx=0; this.vy=0; this.spin=0; this.trail.length=0;
        }
      };

      const goal = { x:0,y:0,w:0,h:0 };

      const keeper = {
        x:0,y:0,w:40,h:60, baseSpeed:180, dir:1, diveTimer:0,
        reset(){
          this.x = goal.x + goal.w*0.5;
          this.y = goal.y + goal.h*0.55;
          this.dir = Math.random()<.5?-1:1;
          this.diveTimer = 0;
        },
        speed(){
          const diffMul = [1,1.2,1.45][difficulty] || 1;
          const timeBoost = 1 + (1 - timeLeft/(selectedMinutes*60)) * 0.6; // harder later
          return this.baseSpeed * diffMul * timeBoost;
        }
      };

      // Obstacles (defenders)
      const obstacles = [];
      function createObstacles(){
        obstacles.length=0;
        const count = 1 + Math.floor((difficulty) + (1 - timeLeft/(selectedMinutes*60))*2); // up to 3
        for(let i=0;i<count;i++){
          const ox = W*0.35 + i*(W*0.3/(Math.max(1,count-1)));
          obstacles.push({
            x:ox, y: H*0.46 + (i%2?20:-20), w:26, h:60,
            vy: (i%2?60:-60)
          });
        }
      }

      // Targets for bonus points/time
      let target = null;
      let targetTimer = 0;
      function spawnTarget(){
        // Corners or center top
        const spots = [
          {x:goal.x+goal.w*0.16, y:goal.y+goal.h*0.18},
          {x:goal.x+goal.w*0.84, y:goal.y+goal.h*0.18},
          {x:goal.x+goal.w*0.5,  y:goal.y+goal.h*0.35}
        ];
        const s = spots[Math.floor(Math.random()*spots.length)];
        target = {x:s.x,y:s.y,r:14,ttl:6}; // seconds
        targetTimer = target.ttl;
      }

      // Wind
      const wind = { x:0, y:0, timer:0 };
      function randomWind(){
        const magBase = [12,22,34][difficulty]||12; // px/s^2 influence
        const mag = (magBase*0.5) + Math.random()*magBase;
        const ang = Math.random()*Math.PI*2;
        wind.x = Math.cos(ang) * mag;
        wind.y = Math.sin(ang) * mag * 0.6; // vertical less impactful
        wind.timer = 12 + Math.random()*10;
        updateWindHUD();
      }
      function updateWindHUD(){
        const m = Math.hypot(wind.x, wind.y);
        windTxt.textContent = Math.round(m);
        const ang = Math.atan2(wind.y, wind.x);
        const deg = ang * 180 / Math.PI;
        windArrow.style.transform = `rotate(${deg}deg)`;
      }

      // Aiming
      let aimStart = null;
      let aimEnd = null;
      let aimPath = []; // for spin estimate

      // Camera shake
      let shake = 0;

      // Utility
      const clamp = (n,min,max)=>Math.max(min,Math.min(max,n));
      const lerp = (a,b,t)=>a+(b-a)*t;
      function formatTime(s){
        const m = Math.floor(s/60);
        const r = Math.floor(s%60);
        return `${m}:${r<10?'0':''}${r}`;
      }

      // Resize
      function resize(){
        const rect = canvas.getBoundingClientRect();
        DPR = Math.max(1, Math.min(3, window.devicePixelRatio||1));
        canvas.width = Math.max(1, Math.floor(rect.width*DPR));
        canvas.height = Math.max(1, Math.floor(rect.height*DPR));
        ctx.setTransform(DPR,0,0,DPR,0,0);
        W = rect.width; H = rect.height;

        // Layout field
        goal.x = W*0.17;
        goal.w = W*0.66;
        goal.h = H*0.22;
        goal.y = H*0.12;

        ball.r = Math.max(10, Math.min(14, Math.round(W/40)));
        keeper.w = Math.max(38, Math.min(54, Math.round(W/20)));
        keeper.h = Math.max(56, Math.min(80, Math.round(H/9)));

        if(state==='menu') {
          // nothing
        }else{
          ball.reset();
          keeper.reset();
          createObstacles();
        }
      }
      window.addEventListener('resize', resize, {passive:true});

      // Init new match
      function newMatch(){
        goals = 0;
        timeLeft = selectedMinutes*60;
        updateHUD();
        ball.reset();
        keeper.reset();
        createObstacles();
        randomWind();
        target=null; targetTimer=0;
        state='ready';
        hint.style.display='block';
      }

      function updateHUD(){
        goalsEl.textContent = goals;
        timeEl.textContent = formatTime(Math.max(0,timeLeft));
      }

      function showOverlay(el, show=true){
        el.style.display = show?'grid':'none';
      }

      // Physics & Update
      function update(dt){
        // Skip when paused/menu/over
        if(state==='menu' || state==='paused' || state==='over') return;

        // Countdown
        timeLeft -= dt;
        if(timeLeft<=0){
          timeLeft=0;
          endMatch();
        }
        updateHUD();

        // Wind timer
        wind.timer -= dt;
        if(wind.timer<=0) randomWind();

        // Target timer
        if(!target){
          if(Math.random()<dt*0.15) spawnTarget();
        }else{
          targetTimer -= dt;
          target.ttl = targetTimer;
          if(targetTimer<=0) target=null;
        }

        // Obstacles move
        for(const o of obstacles){
          o.y += o.vy*dt;
          if(o.y < H*0.36 || o.y > H*0.54) o.vy *= -1;
        }

        // Keeper patrol
        if(state!=='kicked'){
          const speed = keeper.speed();
          keeper.x += keeper.dir * speed * dt;
          if(keeper.x - keeper.w*0.5 < goal.x+8){ keeper.x = goal.x+8+keeper.w*0.5; keeper.dir*=-1; }
          if(keeper.x + keeper.w*0.5 > goal.x+goal.w-8){ keeper.x = goal.x+goal.w-8-keeper.w*0.5; keeper.dir*=-1; }
        }else{
          // After kick, keeper tries to track ball x
          const targetX = clamp(ball.x, goal.x+keeper.w*0.5+4, goal.x+goal.w-keeper.w*0.5-4);
          keeper.x = lerp(keeper.x, targetX, dt*2.2);
        }

        // Ball movement
        if(state==='kicked'){
          // Apply wind and spin (Magnus)
          const drag = 0.06 + difficulty*0.02;
          const fr = Math.max(0, 1 - drag*dt);
          ball.vx *= fr;
          ball.vy *= fr;

          // wind influence (px/s^2 scaled)
          ball.vx += (wind.x/200) * dt;
          ball.vy += (wind.y/230) * dt;

          // spin curve
          const s = clamp(ball.spin, -1.2, 1.2);
          const magnus = 50 + difficulty*23;
          const ax = -s * ball.vy / magnus;
          const ay =  s * ball.vx / magnus;
          ball.vx += ax;
          ball.vy += ay;

          // Move
          ball.x += ball.vx;
          ball.y += ball.vy;

          // Trail
          ball.trail.push({x:ball.x,y:ball.y,a:0.6});
          if(ball.trail.length>22) ball.trail.shift();

          // Collisions: goal area
          const inGoalX = ball.x>goal.x && ball.x<goal.x+goal.w;
          const inGoalY = ball.y>goal.y && ball.y<goal.y+goal.h;
          if(inGoalX && inGoalY){
            // Keeper save?
            if(circleRect(ball.x,ball.y,ball.r, keeper.x-keeper.w/2, keeper.y-keeper.h/2, keeper.w, keeper.h)){
              onSave();
            }else{
              // Net hit -> check if crossed goal line (inside frame)
              onGoal();
            }
          }

          // Collisions: posts (frame)
          // Left post
          if(circleRect(ball.x,ball.y,ball.r, goal.x-6, goal.y, 6, goal.h)){ reflectX(); pingPost(); }
          // Right post
          if(circleRect(ball.x,ball.y,ball.r, goal.x+goal.w, goal.y, 6, goal.h)){ reflectX(); pingPost(); }
          // Crossbar
          if(circleRect(ball.x,ball.y,ball.r, goal.x-6, goal.y-6, goal.w+12, 6)){ reflectY(); pingPost(); }

          // Collisions: obstacles
          for(const o of obstacles){
            if(circleRect(ball.x,ball.y,ball.r, o.x-o.w/2, o.y-o.h/2, o.w, o.h)){
              // Simple reflect: choose axis by penetration depth
              const penX = (o.w/2 + ball.r) - Math.abs(ball.x - o.x);
              const penY = (o.h/2 + ball.r) - Math.abs(ball.y - o.y);
              if(penX < penY) reflectX(); else reflectY();
              createBurst(ball.x,ball.y,'#94a3b8',18);
              audio.save();
              vibrate(60);
            }
          }

          // Target hit
          if(target && dist(ball.x,ball.y,target.x,target.y) < ball.r + target.r){
            goals += 2; // bonus
            timeLeft = Math.min(selectedMinutes*60, timeLeft + 10);
            updateHUD();
            createBurst(target.x,target.y,'#22c55e',36);
            target = null;
            hintFlash("Bonus! +2 goals +10s");
          }

          // Out of bounds -> reset
          if(ball.y < -50 || ball.y > H+60 || ball.x<-60 || ball.x>W+60){
            onMiss();
          }
        }
      }

      function reflectX(){ ball.vx = -ball.vx*0.7; ball.x += ball.vx*0.5 }
      function reflectY(){ ball.vy = -ball.vy*0.7; ball.y += ball.vy*0.5 }
      function pingPost(){ createBurst(ball.x,ball.y,'#f59e0b',22); audio.beep(300,0.05,'square',0.05); vibrate(40) }

      function onGoal(){
        state = 'scored';
        goals += 1;
        updateHUD();
        createBurst(ball.x, ball.y, '#22c55e', 54);
        audio.goal();
        vibrate([90,40,90]);
        pop('‚öΩ');
        shake = 6;
        // quick reset
        setTimeout(()=>{
          ball.reset(); keeper.reset(); createObstacles();
          state='ready';
          hint.style.display='block';
        }, 850);
      }
      function onSave(){
        state='missed';
        createBurst(ball.x, ball.y, '#ef4444', 40);
        audio.save();
        vibrate(80);
        setTimeout(()=>{
          ball.reset(); keeper.reset(); createObstacles();
          state='ready';
          hint.style.display='block';
        }, 700);
      }
      function onMiss(){
        state='missed';
        audio.beep(160,0.08,'sawtooth',0.04);
        setTimeout(()=>{
          ball.reset(); keeper.reset(); createObstacles();
          state='ready';
          hint.style.display='block';
        }, 400);
      }

      // Particles
      const parts=[];
      function createBurst(x,y,color='#ffffff',count=20){
        for(let i=0;i<count;i++){
          const a = Math.random()*Math.PI*2;
          const s = (Math.random()*2+1);
          parts.push({x,y,vx:Math.cos(a)*s*3,vy:Math.sin(a)*s*3,life:1, color});
        }
        while(parts.length>220) parts.shift();
      }
      function updateParticles(dt){
        for(let i=parts.length-1;i>=0;i--){
          const p = parts[i];
          p.x += p.vx;
          p.y += p.vy;
          p.vx *= 0.98; p.vy *= 0.98; p.life -= dt*1.8;
          if(p.life<=0) parts.splice(i,1);
        }
      }

      // Draw
      function draw(){
        // Clear
        ctx.clearRect(0,0,W,H);

        // Field
        drawField();

        // Goal and net
        drawGoal();

        // Target
        if(target){
          ctx.save();
          ctx.globalAlpha = 0.8*(target.ttl/6) + 0.2*Math.sin(performance.now()/120);
          ctx.lineWidth = 3;
          const grad = ctx.createRadialGradient(target.x,target.y,2,target.x,target.y,target.r+6);
          grad.addColorStop(0,'rgba(56,189,248,.1)');
          grad.addColorStop(1,'rgba(56,189,248,.4)');
          ctx.fillStyle = grad;
          ctx.beginPath(); ctx.arc(target.x,target.y,target.r+6,0,Math.PI*2); ctx.fill();
          ctx.strokeStyle = '#38bdf8';
          ctx.beginPath(); ctx.arc(target.x,target.y,target.r,0,Math.PI*2); ctx.stroke();
          ctx.restore();
        }

        // Obstacles
        for(const o of obstacles) drawDefender(o);

        // Keeper
        drawKeeper();

        // Aiming line
        if(state==='aiming' && aimStart && aimEnd){
          drawAim(aimStart, aimEnd);
        }

        // Ball trail
        for(let i=0;i<ball.trail.length;i++){
          const t = ball.trail[i];
          ctx.beginPath();
          ctx.fillStyle = `rgba(255,255,255,${(i/ball.trail.length)*0.35})`;
          ctx.arc(t.x, t.y, Math.max(1, ball.r*(i/ball.trail.length)*0.8), 0, Math.PI*2);
          ctx.fill();
        }

        // Ball
        drawBall();

        // Particles
        for(const p of parts){
          ctx.beginPath();
          ctx.fillStyle = p.color;
          ctx.globalAlpha = Math.max(0,p.life);
          ctx.arc(p.x,p.y, 3.5*p.life, 0, Math.PI*2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        // Camera shake reduction
        if(shake>0){
          shake = Math.max(0, shake-0.3);
        }
      }

      function drawField(){
        // stripes
        const stripes = 10;
        for(let i=0;i<stripes;i++){
          ctx.fillStyle = (i%2)?'rgba(9,83,37,0.95)':'rgba(13,104,47,0.95)';
          const sw = W/stripes;
          ctx.fillRect(i*sw, 0, sw+1, H);
        }
        // penalty box
        ctx.strokeStyle = 'rgba(255,255,255,.25)';
        ctx.lineWidth = 2;
        roundRect(goal.x-50, goal.y-20, goal.w+100, goal.h+100, 12, false, true);
        // center spot around ball
        ctx.beginPath(); ctx.arc(W*0.5, H*0.78, 50, 0, Math.PI*2); ctx.stroke();
      }

      function drawGoal(){
        // frame
        ctx.fillStyle='#e2e8f0';
        ctx.fillRect(goal.x-5, goal.y-4, goal.w+10, 6); // crossbar
        ctx.fillRect(goal.x-5, goal.y-2, 6, goal.h+2);
        ctx.fillRect(goal.x+goal.w-1, goal.y-2, 6, goal.h+2);

        // net
        ctx.strokeStyle='rgba(255,255,255,.22)'; ctx.lineWidth=1;
        const cols=12, rows=6;
        for(let i=0;i<=cols;i++){
          const x = goal.x + (goal.w/cols)*i;
          ctx.beginPath(); ctx.moveTo(x, goal.y+2); ctx.lineTo(x, goal.y+goal.h); ctx.stroke();
        }
        for(let j=0;j<=rows;j++){
          const y = goal.y + (goal.h/rows)*j;
          ctx.beginPath(); ctx.moveTo(goal.x, y); ctx.lineTo(goal.x+goal.w, y); ctx.stroke();
        }
      }

      function drawKeeper(){
        // shadow
        ctx.fillStyle='rgba(0,0,0,.25)';
        ctx.beginPath();
        ctx.ellipse(keeper.x, keeper.y+keeper.h/2, keeper.w/2, 10, 0, 0, Math.PI*2);
        ctx.fill();

        // body
        const g = ctx.createLinearGradient(keeper.x-keeper.w/2, keeper.y-keeper.h/2, keeper.x+keeper.w/2, keeper.y+keeper.h/2);
        g.addColorStop(0, '#0ea5e9'); g.addColorStop(1, '#2563eb');
        ctx.fillStyle = g;
        ctx.fillRect(keeper.x-keeper.w/2, keeper.y-keeper.h/2, keeper.w, keeper.h);

        // gloves
        ctx.fillStyle='#f59e0b';
        ctx.fillRect(keeper.x-keeper.w/2-6, keeper.y-8, 10, 16);
        ctx.fillRect(keeper.x+keeper.w/2-4, keeper.y-8, 10, 16);
      }

      function drawDefender(o){
        // shadow
        ctx.fillStyle='rgba(0,0,0,.2)';
        ctx.beginPath(); ctx.ellipse(o.x, o.y+o.h/2, o.w/2, 8, 0,0,Math.PI*2); ctx.fill();
        // pole
        const grad = ctx.createLinearGradient(o.x-o.w/2,o.y-o.h/2,o.x+o.w/2,o.y+o.h/2);
        grad.addColorStop(0,'#64748b'); grad.addColorStop(1,'#334155');
        ctx.fillStyle = grad;
        roundRect(o.x-o.w/2, o.y-o.h/2, o.w, o.h, 6, true, false);
        // stripe
        ctx.fillStyle='#94a3b8';
        ctx.fillRect(o.x-o.w/2+3, o.y-2, o.w-6, 4);
      }

      function drawBall(){
        // camera shake translate
        if(shake>0){
          const ox = (Math.random()-0.5)*shake;
          const oy = (Math.random()-0.5)*shake;
          ctx.save(); ctx.translate(ox,oy);
        }

        // shadow
        ctx.fillStyle='rgba(0,0,0,.35)';
        ctx.beginPath(); ctx.ellipse(ball.x, ball.y+5, ball.r, ball.r/2, 0,0,Math.PI*2); ctx.fill();

        // ball
        const grad = ctx.createRadialGradient(ball.x-ball.r/3, ball.y-ball.r/3, 2, ball.x, ball.y, ball.r+1);
        grad.addColorStop(0,'#ffffff'); grad.addColorStop(.7,'#eaeaea'); grad.addColorStop(1,'#cfcfcf');
        ctx.fillStyle=grad;
        ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r,0,Math.PI*2); ctx.fill();

        // pattern
        ctx.strokeStyle='#8b8b8b'; ctx.lineWidth=1;
        ctx.beginPath(); ctx.arc(ball.x,ball.y,ball.r-1,0,Math.PI*2); ctx.stroke();

        if(shake>0) ctx.restore();
      }

      function drawAim(a,b){
        const dx=b.x-a.x, dy=b.y-a.y;
        const dist = Math.hypot(dx,dy);
        const nx=dx/dist||0, ny=dy/dist||0;
        // guideline
        ctx.setLineDash([10,8]); ctx.lineWidth=3; ctx.strokeStyle='rgba(255,255,255,.6)';
        ctx.beginPath(); ctx.moveTo(ball.x,ball.y); ctx.lineTo(b.x,b.y); ctx.stroke(); ctx.setLineDash([]);

        // arrow head
        const head = 14;
        const ang = Math.atan2(dy,dx);
        ctx.fillStyle='#a5f3fc';
        ctx.beginPath();
        ctx.moveTo(b.x, b.y);
        ctx.lineTo(b.x - Math.cos(ang-0.4)*head, b.y - Math.sin(ang-0.4)*head);
        ctx.lineTo(b.x - Math.cos(ang+0.4)*head, b.y - Math.sin(ang+0.4)*head);
        ctx.closePath(); ctx.fill();
      }

      // Shapes
      function roundRect(x,y,w,h,r,fill=true,stroke=false){
        const rr = Math.min(r, w/2, h/2);
        ctx.beginPath();
        ctx.moveTo(x+rr,y);
        ctx.arcTo(x+w,y,x+w,y+h,rr);
        ctx.arcTo(x+w,y+h,x,y+h,rr);
        ctx.arcTo(x,y+h,x,y,rr);
        ctx.arcTo(x,y,x+w,y,rr);
        if(fill) ctx.fill();
        if(stroke) ctx.stroke();
      }

      // Collision helpers
      function circleRect(cx,cy,cr, rx,ry,rw,rh){
        const nx = clamp(cx, rx, rx+rw);
        const ny = clamp(cy, ry, ry+rh);
        const dx = cx-nx, dy=cy-ny;
        return dx*dx + dy*dy <= cr*cr;
      }
      function dist(x1,y1,x2,y2){ const dx=x2-x1, dy=y2-y1; return Math.hypot(dx,dy) }

      // Input with Pointer events
      canvas.addEventListener('pointerdown', (e)=>{
        if(state==='menu' || state==='paused' || state==='over') return;
        audio.init();
        canvas.setPointerCapture(e.pointerId);
        state='aiming';
        aimStart = {x:ball.x, y:ball.y};
        aimEnd = {x:e.clientX - canvas.getBoundingClientRect().left, y:e.clientY - canvas.getBoundingClientRect().top};
        aimPath = [{x:aimEnd.x,y:aimEnd.y, t:performance.now()}];
        hint.style.display='none';
        powerBox.style.display='block';
        updatePowerBar();
      });
      canvas.addEventListener('pointermove', (e)=>{
        if(state!=='aiming') return;
        const rect = canvas.getBoundingClientRect();
        aimEnd = {x:e.clientX - rect.left, y:e.clientY - rect.top};
        aimPath.push({x:aimEnd.x,y:aimEnd.y, t:performance.now()});
        if(aimPath.length>16) aimPath.shift();
        updatePowerBar();
      });
      canvas.addEventListener('pointerup', ()=>{
        if(state!=='aiming') return;
        shoot();
      });
      canvas.addEventListener('pointercancel', ()=>{
        if(state==='aiming') { powerBox.style.display='none'; state='ready'; }
      });

      function updatePowerBar(){
        const dx = aimEnd.x - aimStart.x;
        const dy = aimEnd.y - aimStart.y;
        const d = Math.hypot(dx,dy);
        const power = clamp(d / 3.2, 0, 100);
        powerBar.style.width = `${power}%`;
      }

      function shoot(){
        const dx = aimEnd.x - aimStart.x;
        const dy = aimEnd.y - aimStart.y;
        let d = Math.hypot(dx,dy);
        if(d<10){ powerBox.style.display='none'; state='ready'; return; }
        // Power scale by difficulty
        const maxSpeed = 24 + difficulty*4;
        const spd = Math.min(maxSpeed, d/10);
        // dir
        ball.vx = (dx/d) * spd;
        ball.vy = (dy/d) * spd;
        // Spin estimate from path curvature (signed)
        let spin = 0;
        for(let i=2;i<aimPath.length;i++){
          const p0=aimPath[i-2], p1=aimPath[i-1], p2=aimPath[i];
          const v1x=p1.x-p0.x, v1y=p1.y-p0.y;
          const v2x=p2.x-p1.x, v2y=p2.y-p1.y;
          const cross = (v1x*v2y - v1y*v2x);
          spin += cross;
        }
        spin = clamp(spin/60000, -1.2, 1.2); // normalize
        ball.spin = spin;

        state='kicked';
        powerBox.style.display='none';
        createBurst(ball.x,ball.y,'#e2e8f0',14);
        audio.kick();
        vibrate(30);
      }

      // Pause/Resume/Restart
      pauseBtn.addEventListener('click', ()=>{
        if(state==='menu' || state==='over') return;
        state='paused';
        showOverlay(pause,true);
      });
      resumeBtn.addEventListener('click', ()=>{ state='ready'; showOverlay(pause,false); });
      restartBtn.addEventListener('click', ()=>{ showOverlay(pause,false); newMatch(); state='ready'; });
      quitBtn.addEventListener('click', ()=>{ showOverlay(pause,false); showOverlay(menu,true); state='menu'; });

      // Menu selections
      lengthRow.addEventListener('click', e=>{
        const el = e.target.closest('.tag'); if(!el) return;
        [...lengthRow.children].forEach(c=>c.classList.remove('active'));
        el.classList.add('active');
        selectedMinutes = parseInt(el.dataset.min,10)||10;
      });
      difficultyRow.addEventListener('click', e=>{
        const el = e.target.closest('.tag'); if(!el) return;
        [...difficultyRow.children].forEach(c=>c.classList.remove('active'));
        el.classList.add('active');
        difficulty = parseInt(el.dataset.diff,10)||0;
      });
      muteBtn.addEventListener('click', ()=>{
        audio.enabled = !audio.enabled;
        muteBtn.textContent = audio.enabled ? 'üîä Sound On' : 'üîá Sound Off';
        if(audio.enabled) audio.init();
      });
      startBtn.addEventListener('click', ()=>{
        audio.init();
        showOverlay(menu,false);
        newMatch();
      });
      againBtn.addEventListener('click', ()=>{
        showOverlay(over,false);
        showOverlay(menu,true);
        state='menu';
      });

      // End match
      function endMatch(){
        state='over';
        finalGoalsEl.textContent = goals;
        if(goals>best){ best=goals; localStorage.setItem('gk_best', String(best)); }
        finalBestEl.textContent = best;
        setTimeout(()=>showOverlay(over,true), 300);
      }

      // FX
      function pop(char='‚öΩ'){
        const d = document.createElement('div');
        d.className='celebrate'; d.textContent=char;
        document.body.appendChild(d);
        setTimeout(()=>d.remove(), 1000);
      }
      function hintFlash(text){
        hint.textContent = text;
        hint.style.display='block';
        hint.style.animation='none';
        // force reflow
        void hint.offsetWidth;
        hint.style.animation='';
        setTimeout(()=>{ hint.style.display='none'; }, 1200);
      }
      function vibrate(pattern){ if(navigator.vibrate) navigator.vibrate(pattern) }

      // Main loop
      function loop(t){
        const dt = Math.min(0.033, (t-lastTime)/1000);
        lastTime = t;
        update(dt);
        updateParticles(dt);
        draw();
        requestAnimationFrame(loop);
      }

      // Initialize
      resize();
      showOverlay(menu,true);
      requestAnimationFrame(loop);

      // Prevent scroll on iOS
      document.addEventListener('touchmove', e=>e.preventDefault(), {passive:false});

      // Accessibility keyboard quick controls (optional)
      window.addEventListener('keydown', (e)=>{
        if(e.key===' '){
          if(state==='paused'){ resumeBtn.click(); }
          else if(state!=='menu' && state!=='over'){ pauseBtn.click(); }
        }
      });
    })();
  </script>
</body>
</html>