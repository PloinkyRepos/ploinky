<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, viewport-fit=cover"/>
  <title>Neon Strike: Alien Defense</title>
  <style>
    :root{
      --bg1:#04060c;
      --bg2:#0a1021;
      --grid:#0e1837;
      --fg:#e6f0ff;
      --accent:#00d4ff;
      --accent2:#00ffa6;
      --danger:#ff3d5a;
      --enemy:#8dfc2d;
      --ship:#20c8ff;
      --power:#5df2ff;
      --shadow:rgba(0,255,255,.25);
    }
    *{box-sizing:border-box; -webkit-tap-highlight-color:transparent}
    html,body{height:100svh;margin:0;overflow:hidden;background:radial-gradient(1200px 800px at 70% -10%,#0a1738 0%,transparent 60%),linear-gradient(180deg,var(--bg1),var(--bg2));color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    canvas{width:100%;height:100%;display:block;touch-action:none}
    .hud{position:fixed;inset:env(safe-area-inset-top) 12px auto 12px;display:flex;align-items:center;gap:8px;justify-content:space-between;pointer-events:none}
    .leftHUD,.rightHUD{display:flex;gap:8px;align-items:center}
    .pill{pointer-events:auto;background:rgba(0,10,26,.45);backdrop-filter:blur(6px);border:1px solid rgba(0,255,255,.15);border-radius:14px;padding:6px 10px;font-weight:700;letter-spacing:.3px;box-shadow:0 0 0 1px rgba(255,255,255,.03) inset}
    .bar{position:relative;width:140px;height:12px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);overflow:hidden}
    .bar>i{position:absolute;left:0;top:0;bottom:0;width:0;background:linear-gradient(90deg,var(--accent),#2bffd0);box-shadow:0 0 12px rgba(0,255,255,.5) inset}
    .tiny{opacity:.9;font-weight:600}
    .btn{pointer-events:auto;cursor:pointer;user-select:none}
    .btn:active{transform:translateY(1px)}
    .hidden{display:none}
    .overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(2,6,15,.8),rgba(2,6,15,.65));backdrop-filter:blur(2px)}
    .card{max-width:min(700px,92vw);text-align:center;padding:22px 18px;border-radius:18px;background:linear-gradient(180deg,rgba(0,15,35,.7),rgba(0,10,25,.5));border:1px solid rgba(0,255,255,.2);box-shadow:0 20px 60px rgba(0,0,0,.45)}
    h1{margin:6px 0 6px;font-size:28px;letter-spacing:.8px;color:#c8e9ff;text-shadow:0 0 18px rgba(0,180,255,.35)}
    p{margin:6px 0;color:#b8d0ff}
    .cta{display:inline-block;margin-top:10px;padding:12px 18px;border-radius:14px;font-weight:800;letter-spacing:.6px;background:linear-gradient(90deg,var(--accent),#58ffd1);color:#002033;border:none;cursor:pointer;box-shadow:0 6px 26px rgba(0,220,255,.35)}
    .sub{font-size:12px;opacity:.85}
    .gridOverlay{position:fixed;inset:0;pointer-events:none;opacity:.14}
    .touchHints{position:fixed;left:0;right:0;bottom:max(10px,env(safe-area-inset-bottom));display:flex;justify-content:space-between;gap:10px;padding:0 10px;pointer-events:none}
    .hint{pointer-events:none;color:#9ecbff;font-size:12px;background:rgba(0,15,35,.4);border:1px solid rgba(0,255,255,.15);padding:6px 8px;border-radius:10px}
  </style>
</head>
<body>
  <div class="gridOverlay" aria-hidden="true"></div>
  <div class="hud">
    <div class="leftHUD">
      <div class="pill tiny">Score: <span id="score">000000</span></div>
      <div class="pill tiny">Level: <span id="level">1</span></div>
      <div class="pill tiny">Lives: <span id="lives">3</span></div>
      <div class="pill tiny" style="display:flex;align-items:center;gap:6px">
        Shield
        <span class="bar" style="width:120px"><i id="shieldFill"></i></span>
      </div>
    </div>
    <div class="rightHUD">
      <div id="pauseBtn" class="pill btn" title="Pause">‚è∏</div>
      <div id="muteBtn" class="pill btn" title="Mute">üîä</div>
    </div>
  </div>

  <div class="touchHints">
    <div class="hint">Drag anywhere to move</div>
    <div class="hint">Auto-fire ON</div>
  </div>

  <div id="overlay" class="overlay">
    <div class="card">
      <h1>Neon Strike: Alien Defense</h1>
      <p>Drag to move your fighter. Auto-fire is enabled.</p>
      <p>Survive waves, dodge enemy fire, collect power-ups, and climb levels.</p>
      <p class="sub">Tip: Your shield recharges slowly. Don't let enemies slip by!</p>
      <button id="startBtn" class="cta">Start Mission</button>
    </div>
  </div>

  <canvas id="c" aria-label="Game Canvas"></canvas>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const ctx = canvas.getContext('2d', { alpha: true, desynchronized: true });
      let DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
      let W = 0, H = 0;

      const state = {
        running: false,
        muted: false,
        t: 0,
        last: 0,
        score: 0,
        level: 1,
        timeSurvived: 0,
        lives: 3,
        shield: 80,
        shieldMax: 100,
        invuln: 0,
        autofire: true
      };

      // Ship
      const ship = {
        x: 0, y: 0, r: 14,
        speed: 800,
        targetX: 0,
        fireCd: 0,
        fireRate: 0.22,
        spread: false,
        spreadTimer: 0,
        rapidTimer: 0
      };

      // Collections
      let stars = [];
      const bullets = [];
      const enemies = [];
      const eBullets = [];
      const particles = [];
      const powerups = [];

      // UI elements
      const elScore = document.getElementById('score');
      const elLevel = document.getElementById('level');
      const elLives = document.getElementById('lives');
      const elShieldFill = document.getElementById('shieldFill');
      const overlay = document.getElementById('overlay');
      const startBtn = document.getElementById('startBtn');
      const pauseBtn = document.getElementById('pauseBtn');
      const muteBtn = document.getElementById('muteBtn');

      // Audio (minimal, muted by default toggle)
      const audioCtx = typeof AudioContext !== 'undefined' ? new AudioContext() : null;
      function beep(freq=440, dur=0.06, vol=0.03) {
        if (state.muted || !audioCtx) return;
        const t = audioCtx.currentTime;
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = 'square';
        o.frequency.value = freq;
        g.gain.setValueAtTime(vol, t);
        g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
        o.connect(g).connect(audioCtx.destination);
        o.start(t); o.stop(t + dur);
      }

      // Resize handling
      function resize() {
        DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
        const r = canvas.getBoundingClientRect();
        W = Math.max(320, Math.floor(r.width));
        H = Math.max(320, Math.floor(r.height));
        canvas.width = Math.floor(W * DPR);
        canvas.height = Math.floor(H * DPR);
        ctx.setTransform(DPR, 0, 0, DPR, 0, 0);

        // Rebuild starfield
        buildStars();
        // Position ship
        ship.x = Math.min(Math.max(ship.x || W * 0.5, 20), W - 20);
        ship.y = H - 80;
        ship.targetX = ship.x;
      }
      window.addEventListener('resize', resize, { passive: true });
      resize();

      // Starfield layers
      function buildStars() {
        const count = Math.floor((W * H) / 12000);
        stars = [];
        for (let i = 0; i < count; i++) {
          stars.push({
            x: Math.random() * W,
            y: Math.random() * H,
            z: Math.random() * 1 + 0.2, // depth
            s: Math.random() * 1.5 + 0.2, // size
            tw: Math.random() * 6.28
          });
        }
      }

      // Difficulty tuning for 10-15 min session
      let spawnTimer = 0;
      function difficulty() {
        const t = state.timeSurvived;
        const level = 1 + Math.floor(t / 45); // level up every 45s
        state.level = Math.min(level, 25);
        const speedScale = 1 + Math.min(t / (12 * 60), 0.8); // up to 1.8x over ~12min
        const spawnInterval = Math.max(0.3, 1.2 - t / 120); // 1.2s down to 0.3s
        const shooterProb = Math.min(0.35, 0.08 + t / 300); // up to 35%
        const tankProb = Math.min(0.25, 0.06 + t / 360);
        const zigProb = Math.min(0.35, 0.12 + t / 300);
        return { speedScale, spawnInterval, shooterProb, tankProb, zigProb };
      }

      function spawnEnemy() {
        const d = difficulty();
        const r = Math.random();
        let type = 'normal';
        if (r < d.shooterProb) type = 'shooter';
        else if (r < d.shooterProb + d.tankProb) type = 'tank';
        else if (r < d.shooterProb + d.tankProb + d.zigProb) type = 'zigzag';

        const y = 60 + Math.random() * Math.max(120, H * 0.6);
        const speed = (60 + Math.random() * 80) * d.speedScale;
        let hp = 1, radius = 12, color = getVar('--enemy');
        let shootCd = 0, pattern = Math.random() * 1000;

        if (type === 'tank') { hp = 3; radius = 14; }
        if (type === 'shooter') { hp = 2; radius = 12; shootCd = 1.2; }
        if (type === 'zigzag') { hp = 1; radius = 11; }

        enemies.push({
          type, x: W + 30, y, r: radius, hp, color,
          vx: -speed, vy: 0, t: 0, shootCd, pattern
        });
      }

      function spawnPowerup(x, y) {
        // 15% chance
        if (Math.random() > 0.15) return;
        const r = Math.random();
        const kind = r < 0.34 ? 'shield' : (r < 0.67 ? 'rapid' : 'spread');
        powerups.push({ x, y, kind, vy: 60 + Math.random() * 40, r: 10, t: 0 });
      }

      function addExplosion(x, y, color, n=14, spread=240) {
        for (let i = 0; i < n; i++) {
          const a = Math.random() * Math.PI * 2;
          const s = Math.random() * spread + 80;
          particles.push({
            x, y, vx: Math.cos(a) * s, vy: Math.sin(a) * s,
            life: 0.6 + Math.random() * 0.4,
            t: 0, color, size: 2 + Math.random() * 2
          });
        }
      }

      function addThrust(x, y) {
        particles.push({
          x, y, vx: (Math.random()*2-1) * 40, vy: 150 + Math.random() * 60,
          life: 0.25, t: 0, color: 'rgba(0,220,255,.6)', size: 1.6
        });
      }

      function fireBullet() {
        const nowCd = ship.fireRate * (ship.rapidTimer > 0 ? 0.5 : 1);
        if (ship.fireCd > 0) return;
        ship.fireCd = nowCd;
        const y = ship.y - ship.r - 6;
        const base = { x: ship.x, y, vx: 0, vy: -620, r: 3, color: getVar('--danger') };
        if (ship.spread || ship.rapidTimer > 0) {
          const angle = 0.26;
          bullets.push({ ...base, vx: -240 * Math.sin(angle), vy: base.vy * Math.cos(angle) });
          bullets.push(base);
          bullets.push({ ...base, vx: 240 * Math.sin(angle), vy: base.vy * Math.cos(angle) });
        } else {
          bullets.push(base);
        }
        beep(520, 0.045, 0.035);
      }

      function enemyFire(e) {
        const speed = 260 + Math.random() * 60;
        const angle = Math.atan2((ship.y - e.y), (ship.x - e.x));
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        eBullets.push({ x: e.x, y: e.y, vx, vy, r: 3.5, color: '#a96bff' });
        beep(320, 0.05, 0.03);
      }

      function getVar(name) {
        return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
      }

      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      // Input
      let keys = {};
      let pointerId = null;
      function onPointerDown(e) {
        pointerId = e.pointerId;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        ship.targetX = x;
        if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      }
      function onPointerMove(e) {
        if (pointerId !== null && e.pointerId !== pointerId) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        ship.targetX = x;
      }
      function onPointerUp(e) {
        if (e.pointerId === pointerId) pointerId = null;
      }
      function onKey(e, d) {
        const k = e.key.toLowerCase();
        if (k === 'arrowleft' || k === 'a') keys.left = d;
        if (k === 'arrowright' || k === 'd') keys.right = d;
        if (k === ' ' || k === 'spacebar') { e.preventDefault(); }
        if (k === 'p') togglePause();
        if (k === 'm') toggleMute();
      }
      canvas.addEventListener('pointerdown', onPointerDown);
      canvas.addEventListener('pointermove', onPointerMove);
      window.addEventListener('pointerup', onPointerUp);
      window.addEventListener('keydown', e => onKey(e, true));
      window.addEventListener('keyup', e => onKey(e, false));

      pauseBtn.addEventListener('click', () => togglePause());
      muteBtn.addEventListener('click', () => toggleMute());
      startBtn.addEventListener('click', () => startGame());

      function togglePause() {
        if (!state.running) return;
        state.paused = !state.paused;
        pauseBtn.textContent = state.paused ? '‚ñ∂' : '‚è∏';
        if (!state.paused) {
          state.last = performance.now();
          requestAnimationFrame(loop);
        }
      }
      function toggleMute() {
        state.muted = !state.muted;
        muteBtn.textContent = state.muted ? 'üîá' : 'üîä';
      }

      function startGame() {
        // Reset game
        state.running = true;
        state.paused = false;
        state.t = 0;
        state.last = performance.now();
        state.score = 0;
        state.level = 1;
        state.timeSurvived = 0;
        state.lives = 3;
        state.shield = 80;
        state.invuln = 1.2;
        ship.x = W * 0.5; ship.y = H - 80; ship.targetX = ship.x;
        ship.fireCd = 0; ship.spread = false; ship.spreadTimer = 0; ship.rapidTimer = 0;
        bullets.length = enemies.length = eBullets.length = particles.length = powerups.length = 0;
        spawnTimer = 0.4;
        overlay.classList.add('hidden');
        pauseBtn.textContent = '‚è∏';
        requestAnimationFrame(loop);
      }

      function gameOver() {
        state.running = false;
        overlay.classList.remove('hidden');
        overlay.innerHTML = `
          <div class="card">
            <h1>Mission Failed</h1>
            <p>Your score: <b>${state.score.toLocaleString()}</b> | Level: <b>${state.level}</b></p>
            <p class="sub">Tip: Grab power-ups and keep your shield charged.</p>
            <button id="restartBtn" class="cta">Try Again</button>
          </div>`;
        document.getElementById('restartBtn').addEventListener('click', () => {
          // restore overlay content to start screen content
          overlay.innerHTML = `
            <div class="card">
              <h1>Neon Strike: Alien Defense</h1>
              <p>Drag to move your fighter. Auto-fire is enabled.</p>
              <p>Survive waves, dodge enemy fire, collect power-ups, and climb levels.</p>
              <p class="sub">Tip: Your shield recharges slowly. Don't let enemies slip by!</p>
              <button id="startBtn" class="cta">Start Mission</button>
            </div>`;
          document.getElementById('startBtn').addEventListener('click', () => startGame());
        }, { once: true });
      }

      // Main loop
      function loop(ts) {
        if (!state.running || state.paused) return;
        const dt = Math.min(0.033, (ts - state.last) / 1000 || 0.016);
        state.last = ts;
        state.t += dt;
        update(dt);
        draw();
        requestAnimationFrame(loop);
      }

      function update(dt) {
        // HUD updates
        elScore.textContent = state.score.toString().padStart(6, '0');
        elLevel.textContent = state.level;
        elLives.textContent = state.lives;
        elShieldFill.style.width = (state.shield / state.shieldMax * 100).toFixed(1) + '%';

        state.timeSurvived += dt;

        // Input to movement
        let move = 0;
        if (keys.left) move -= 1;
        if (keys.right) move += 1;
        if (move !== 0) {
          ship.targetX = clamp(ship.x + move * ship.speed * 0.12, 14, W - 14);
        }
        const dx = ship.targetX - ship.x;
        ship.x += dx * Math.min(1, dt * 12); // ease
        ship.x = clamp(ship.x, 14, W - 14);
        ship.y = H - 80;

        // Auto fire
        if (state.autofire) fireBullet();
        ship.fireCd = Math.max(0, ship.fireCd - dt);

        // Power timers
        if (ship.spreadTimer > 0) {
          ship.spreadTimer -= dt;
          if (ship.spreadTimer <= 0) ship.spread = false;
        }
        if (ship.rapidTimer > 0) {
          ship.rapidTimer -= dt;
        }

        // Shield recharge
        if (state.invuln <= 0) {
          state.shield = Math.min(state.shieldMax, state.shield + 6 * dt);
        }
        state.invuln = Math.max(0, state.invuln - dt);

        // Spawning
        const d = difficulty();
        spawnTimer -= dt;
        if (spawnTimer <= 0) {
          const batch = Math.random() < 0.35 ? 2 : 1;
          for (let i = 0; i < batch; i++) spawnEnemy();
          spawnTimer = d.spawnInterval * (0.7 + Math.random() * 0.6);
        }

        // Update enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          e.t += dt;
          if (e.type === 'zigzag') {
            e.vy = Math.sin(e.t * 4 + e.pattern) * 80;
          } else if (e.type === 'normal') {
            e.vy = Math.sin((e.t + e.pattern) * 1.6) * 30;
          } else {
            e.vy = 0;
          }
          e.x += e.vx * dt;
          e.y += e.vy * dt;

          // Shooters fire
          if (e.type === 'shooter') {
            e.shootCd -= dt;
            if (e.shootCd <= 0 && e.x < W - 80) {
              e.shootCd = 1.2 + Math.random() * 0.6;
              enemyFire(e);
            }
          }

          // Passed through
          if (e.x < -e.r - 20) {
            enemies.splice(i, 1);
            // Penalize: lose life if enemy slips past
            damagePlayer(1, false);
            continue;
          }
        }

        // Update bullets
        for (let i = bullets.length - 1; i >= 0; i--) {
          const b = bullets[i];
          b.x += b.vx * dt; b.y += b.vy * dt;
          if (b.y < -20 || b.x < -20 || b.x > W + 20) {
            bullets.splice(i, 1);
          }
        }

        // Update enemy bullets
        for (let i = eBullets.length - 1; i >= 0; i--) {
          const b = eBullets[i];
          b.x += b.vx * dt; b.y += b.vy * dt;
          if (b.y > H + 30 || b.x < -30 || b.x > W + 30) eBullets.splice(i, 1);
        }

        // Update particles
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.t += dt;
          p.x += p.vx * dt; p.y += p.vy * dt;
          p.vx *= 0.985; p.vy *= 0.985;
          if (p.t > p.life) particles.splice(i, 1);
        }
        // Ship thrust
        if (Math.abs(dx) > 2 && Math.random() < 0.8) addThrust(ship.x + (Math.random()*8-4), ship.y + ship.r);

        // Powerups
        for (let i = powerups.length - 1; i >= 0; i--) {
          const p = powerups[i];
          p.t += dt;
          p.y += p.vy * dt;
          if (p.y > H + 20) powerups.splice(i, 1);
        }

        // Collisions: bullets vs enemies
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          for (let j = bullets.length - 1; j >= 0; j--) {
            const b = bullets[j];
            const dx = e.x - b.x, dy = e.y - b.y;
            const rr = (e.r + b.r) * (e.r + b.r);
            if (dx*dx + dy*dy <= rr) {
              bullets.splice(j, 1);
              e.hp -= 1;
              addExplosion(b.x, b.y, 'rgba(255,80,120,.7)', 4, 120);
              if (e.hp <= 0) {
                enemies.splice(i, 1);
                state.score += e.type === 'tank' ? 30 : e.type === 'shooter' ? 25 : e.type === 'zigzag' ? 20 : 12;
                addExplosion(e.x, e.y, 'rgba(140,255,120,.85)', 16, 300);
                spawnPowerup(e.x, e.y);
                beep(700, 0.06, 0.045);
              } else {
                beep(600, 0.03, 0.03);
              }
              break;
            }
          }
        }

        // Collisions: enemy bullets vs ship
        for (let i = eBullets.length - 1; i >= 0; i--) {
          const b = eBullets[i];
          const dx = ship.x - b.x, dy = ship.y - b.y;
          const rr = (ship.r + b.r) * (ship.r + b.r);
          if (dx*dx + dy*dy <= rr) {
            eBullets.splice(i, 1);
            damagePlayer(1, true);
          }
        }

        // Collisions: enemies vs ship
        for (let i = enemies.length - 1; i >= 0; i--) {
          const e = enemies[i];
          const dx = ship.x - e.x, dy = ship.y - e.y;
          const rr = (ship.r + e.r) * (ship.r + e.r);
          if (dx*dx + dy*dy <= rr) {
            enemies.splice(i, 1);
            addExplosion(e.x, e.y, 'rgba(255,120,160,.8)', 14, 320);
            damagePlayer(2, true);
          }
        }

        // Powerup pickup
        for (let i = powerups.length - 1; i >= 0; i--) {
          const p = powerups[i];
          const dx = ship.x - p.x, dy = ship.y - p.y;
          const rr = (ship.r + p.r) * (ship.r + p.r);
          if (dx*dx + dy*dy <= rr) {
            powerups.splice(i, 1);
            if (p.kind === 'shield') {
              state.shield = Math.min(state.shieldMax, state.shield + 45);
              addExplosion(ship.x, ship.y, 'rgba(0,255,220,.8)', 12, 180);
            } else if (p.kind === 'rapid') {
              ship.rapidTimer = 10;
              addExplosion(ship.x, ship.y, 'rgba(0,220,255,.8)', 10, 220);
            } else if (p.kind === 'spread') {
              ship.spread = true;
              ship.spreadTimer = 12;
              addExplosion(ship.x, ship.y, 'rgba(90,255,180,.8)', 10, 220);
            }
            state.score += 8;
            beep(900, 0.07, 0.05);
          }
        }

        // End game?
        if (state.lives <= 0) {
          gameOver();
        }
      }

      function damagePlayer(amount, fromHit) {
        if (state.invuln > 0) return;
        let remaining = amount;
        if (state.shield > 0) {
          const absorbed = Math.min(state.shield, remaining * 25); // absorb scaled
          state.shield -= absorbed;
          remaining -= absorbed / 25;
        }
        if (remaining > 0.2) {
          state.lives -= 1;
          elLives.textContent = state.lives;
          addExplosion(ship.x, ship.y, 'rgba(255,60,80,.9)', 24, 420);
          beep(180, 0.12, 0.06);
          state.invuln = 1.2;
        } else {
          // shield hit only
          beep(260, 0.05, 0.04);
        }
      }

      function drawBackground() {
        // Space grid lines for a cool vibe
        const g = document.querySelector('.gridOverlay');
        const size = 48;
        const c2 = document.createElement('canvas');
        c2.width = size; c2.height = size;
        const x2 = c2.getContext('2d');
        x2.strokeStyle = 'rgba(0, 180, 255, .12)';
        x2.lineWidth = 1;
        x2.beginPath();
        x2.moveTo(size, 0); x2.lineTo(0, 0); x2.lineTo(0, size);
        x2.stroke();
        g.style.backgroundImage = `url(${c2.toDataURL()})`;
        g.style.backgroundSize = `${size}px ${size}px`;
      }
      drawBackground();

      function draw() {
        ctx.clearRect(0, 0, W, H);

        // Parallax stars
        ctx.save();
        for (let i = 0; i < stars.length; i++) {
          const s = stars[i];
          s.x -= (22 + 60 * s.z) * (1/60);
          if (s.x < -2) s.x += W + 2;
          s.tw += 0.03 * s.z;
          const twinkle = 0.5 + Math.abs(Math.sin(s.tw)) * 0.5;
          ctx.fillStyle = `rgba(200,240,255,${0.25 + 0.55 * s.z * twinkle})`;
          ctx.fillRect(s.x, s.y, s.s, s.s);
        }
        ctx.restore();

        // Draw UI extras when invulnerable
        if (state.invuln > 0) {
          ctx.save();
          ctx.strokeStyle = 'rgba(255,255,255,.07)';
          ctx.lineWidth = 2;
          ctx.setLineDash([6, 8]);
          ctx.beginPath();
          ctx.arc(ship.x, ship.y, ship.r + 18 + Math.sin(state.t * 6) * 2, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
        }

        // Draw bullets
        for (const b of bullets) {
          ctx.save();
          ctx.shadowColor = 'rgba(255,90,120,.6)';
          ctx.shadowBlur = 12;
          ctx.fillStyle = b.color;
          ctx.fillRect(b.x - 2, b.y - 10, 4, 14);
          ctx.restore();
        }

        // Draw enemy bullets
        for (const b of eBullets) {
          ctx.save();
          ctx.shadowColor = 'rgba(160,120,255,.6)';
          ctx.shadowBlur = 10;
          ctx.fillStyle = b.color;
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        // Draw enemies
        for (const e of enemies) {
          ctx.save();
          ctx.shadowColor = 'rgba(140,255,120,.4)';
          ctx.shadowBlur = 12;
          const grad = ctx.createRadialGradient(e.x - 4, e.y - 4, 2, e.x, e.y, e.r + 4);
          if (e.type === 'tank') {
            grad.addColorStop(0, 'rgba(200,255,160,1)');
            grad.addColorStop(1, 'rgba(120,220,80,1)');
          } else if (e.type === 'shooter') {
            grad.addColorStop(0, 'rgba(140,240,255,1)');
            grad.addColorStop(1, 'rgba(50,180,255,1)');
          } else {
            grad.addColorStop(0, 'rgba(180,255,140,1)');
            grad.addColorStop(1, 'rgba(120,220,90,1)');
          }
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgba(0,0,0,.25)';
          ctx.stroke();
          ctx.restore();

          // health pips
          if (e.hp > 1) {
            ctx.fillStyle = 'rgba(0,0,0,.3)';
            ctx.fillRect(e.x - e.r, e.y - e.r - 8, e.r * 2, 4);
            ctx.fillStyle = 'rgba(255,255,255,.85)';
            ctx.fillRect(e.x - e.r, e.y - e.r - 8, (e.r * 2) * (e.hp / (e.type === 'tank' ? 3 : 2)), 4);
          }
        }

        // Draw powerups
        for (const p of powerups) {
          ctx.save();
          ctx.shadowColor = 'rgba(0,255,220,.6)';
          ctx.shadowBlur = 12;
          let color = getVar('--power');
          if (p.kind === 'rapid') color = '#54f2ff';
          if (p.kind === 'spread') color = '#58ffb7';
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fill();
          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgba(0,0,0,.25)';
          ctx.stroke();
          ctx.restore();

          // icon
          ctx.fillStyle = 'rgba(0,30,40,.9)';
          ctx.font = 'bold 10px system-ui';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          const label = p.kind === 'shield' ? 'S' : (p.kind === 'rapid' ? 'R' : 'W');
          ctx.fillText(label, p.x, p.y + 0.5);
        }

        // Draw particles
        for (const p of particles) {
          const a = 1 - (p.t / p.life);
          ctx.fillStyle = p.color.replace(')', `,${Math.max(0, Math.min(1, a))})`).replace('rgb(', 'rgba(');
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        }

        // Draw ship
        ctx.save();
        ctx.translate(ship.x, ship.y);
        ctx.shadowColor = 'rgba(0,220,255,.6)';
        ctx.shadowBlur = 18;
        ctx.fillStyle = getVar('--ship');
        ctx.strokeStyle = 'rgba(0,0,0,.35)';
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.moveTo(0, -ship.r - 4);
        ctx.lineTo(-ship.r, ship.r);
        ctx.lineTo(ship.r, ship.r);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // cockpit
        ctx.fillStyle = 'rgba(255,255,255,.9)';
        ctx.beginPath();
        ctx.arc(0, 0, 3, 0, Math.PI * 2);
        ctx.fill();

        // engine glow
        const glow = 6 + Math.random() * 4;
        const grad = ctx.createRadialGradient(0, ship.r + 6, 0, 0, ship.r + 6, glow);
        grad.addColorStop(0, 'rgba(0,240,255,.9)');
        grad.addColorStop(1, 'rgba(0,240,255,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(0, ship.r + 6, glow, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // Kick things off with menu visible but canvas ready
      // Prevent context menu on long press
      window.addEventListener('contextmenu', e => e.preventDefault());

      // Make canvas focusable to capture keys on desktop
      canvas.tabIndex = 1;

      // Start in idle state; user taps Start Mission
    })();
  </script>
</body>
</html>