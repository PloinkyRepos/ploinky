<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no">
  <title>Arc & »öintƒÉ+ (Enhanced)</title>
  <style>
    :root{
      --bg1:#0a0f1e; --bg2:#141b32;
      --card:#0e1630; --glass:rgba(255,255,255,.08);
      --accent:#5aa0ff; --accent2:#7c4dff;
      --ok:#29d39a; --warn:#ffcc00; --bad:#ff5964;
      --text:#eef3ff; --muted:#b6c3ff;
      --shadow:0 10px 30px rgba(0,0,0,.35);
    }
    html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 70% 50%, #122045, var(--bg2) 60%), linear-gradient(180deg,var(--bg1),var(--bg2));
      color:var(--text);font-family:system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Ubuntu, Cantarell, Arial;overscroll-behavior:none}
    *{box-sizing:border-box}
    canvas{display:block;width:100%;height:100%;touch-action:none;-webkit-user-select:none;user-select:none}
    .hud{position:fixed;top:calc(env(safe-area-inset-top,0px) + 10px);left:10px;right:10px;display:flex;align-items:center;justify-content:space-between;gap:8px;pointer-events:none;z-index:5}
    .hud-left,.hud-right{display:flex;gap:8px;align-items:center}
    .pill{background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.08);border-radius:999px;padding:6px 12px;font-weight:700;font-size:14px;backdrop-filter:blur(6px);box-shadow:var(--shadow);pointer-events:auto}
    .pill[data-accent]{border-color:rgba(90,160,255,.35)}
    .pill small{opacity:.75;font-weight:600}
    .btn{appearance:none;border:1px solid var(--glass);background:rgba(255,255,255,.06);color:var(--text);border-radius:999px;padding:8px 14px;font-weight:800;letter-spacing:.5px;cursor:pointer;backdrop-filter:blur(8px);box-shadow:var(--shadow);pointer-events:auto;transition:transform .08s ease, background .15s ease, border-color .15s ease}
    .btn:active{transform:scale(.97)}
    .btn[aria-pressed="true"]{background:rgba(255,255,255,.12);border-color:rgba(255,255,255,.25)}
    .hint{position:fixed;bottom:calc(env(safe-area-inset-bottom,0px) + 14px);left:0;right:0;text-align:center;font-size:13px;opacity:.85;padding:0 12px;z-index:4}
    .overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;padding:24px;z-index:10}
    .overlay.show{display:flex}
    .panel{width:min(560px, 94vw);background:rgba(15,20,40,.7);border:1px solid rgba(255,255,255,.08);border-radius:18px;padding:18px 16px 16px;backdrop-filter:blur(10px);box-shadow:var(--shadow);text-align:center}
    .panel h1{margin:6px 0 4px;font-size:28px;letter-spacing:.5px}
    .panel h2{margin:6px 0 0;font-size:22px}
    .panel p{margin:6px 0 10px;color:var(--muted)}
    .panel .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-top:12px}
    .panel .row{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;margin:10px 0}
    .kbd{display:inline-block;border:1px solid rgba(255,255,255,.15);border-bottom-width:3px;border-radius:8px;padding:4px 8px;margin:2px;background:rgba(255,255,255,.06);font-weight:800}
    .list{margin:8px auto 0;max-width:44ch;text-align:left;font-size:14px;color:#ccd6ff}
    .list li{margin:6px 0}
    .badge{display:inline-block;padding:3px 8px;border-radius:999px;background:rgba(90,160,255,.15);border:1px solid rgba(90,160,255,.35);font-weight:700;color:#dbe7ff}
    @media (min-width:600px){
      .pill{font-size:15px}
      .hint{font-size:14px}
      .panel h1{font-size:32px}
    }
    .blink{animation:blink 1.2s infinite}
    @keyframes blink{0%,50%{opacity:1}60%{opacity:.3}100%{opacity:1}}
    .float{animation:float 3.2s ease-in-out infinite}
    @keyframes float{0%,100%{transform:translateY(-2px)}50%{transform:translateY(2px)}}
    .glow{box-shadow:0 0 0 0 rgba(90,160,255,.5);animation:glow 2.2s ease-out infinite}
    @keyframes glow{from{box-shadow:0 0 0 0 rgba(90,160,255,.45)}to{box-shadow:0 0 0 16px rgba(90,160,255,0)}}
  </style>
</head>
<body>
  <div class="hud" aria-hidden="false">
    <div class="hud-left">
      <div class="pill" id="scorePill" data-accent>Scor: <span id="score">0</span></div>
      <div class="pill">Best: <span id="best">0</span></div>
      <div class="pill" id="livesPill"><span id="lives">‚ù§‚ù§‚ù§</span></div>
      <div class="pill">Lv <span id="level">1</span></div>
    </div>
    <div class="hud-right">
      <button class="btn glow" id="btnPause" aria-label="PauzƒÉ (P)">PauzƒÉ</button>
    </div>
  </div>

  <div class="hint" id="hint">
    »öine apƒÉsat sau gliseazƒÉ spre st√¢nga pentru a √Æntinde coarda, elibereazƒÉ pentru a trage ‚Ä¢ SƒÉgeatƒÉ sus/jos pentru a »õinti ‚Ä¢ Space/Enter pentru a trage ‚Ä¢ P pentru pauzƒÉ
  </div>

  <div class="overlay show" id="ovStart" aria-modal="true" role="dialog">
    <div class="panel">
      <h1>Arc & »öintƒÉ+</h1>
      <p>Love»ôte »õinta, str√¢nge puncte »ôi supravie»õuie»ôte c√¢t mai mult.</p>
      <div class="row">
        <span class="badge">Responsiv</span>
        <span class="badge">Touch + TastaturƒÉ</span>
        <span class="badge">Power‚Äëup‚Äëuri</span>
        <span class="badge">Scor & Best</span>
      </div>
      <ul class="list">
        <li>»öine apƒÉsat sau gliseazƒÉ spre st√¢nga pentru a √Æntinde, elibereazƒÉ pentru a trage.</li>
        <li>SƒÉgeatƒÉ sus/jos pentru a »õinti fin. Space/Enter pentru a √Æntinde/elibera.</li>
        <li>Love»ôte power‚Äëup‚Äëurile plutitoare: √éncetinire, »öintƒÉ Mare, x2 Scor.</li>
        <li>Greutatea cre»ôte treptat. Ai 3 vie»õi. BaftƒÉ!</li>
      </ul>
      <div class="grid">
        <button id="btnStart" class="btn" style="font-size:18px">JoacƒÉ</button>
        <button id="btnMute" class="btn" aria-pressed="false">üîà Sunet</button>
      </div>
      <p class="blink" style="margin-top:10px;color:#cfe0ff">ApasƒÉ JoacƒÉ pentru a √Æncepe</p>
    </div>
  </div>

  <div class="overlay" id="ovPause" aria-modal="true" role="dialog">
    <div class="panel">
      <h2>PauzƒÉ</h2>
      <p>RespirƒÉ ad√¢nc. »öinta nu pleacƒÉ nicƒÉieri.</p>
      <div class="grid">
        <button id="btnResume" class="btn">ContinuƒÉ (P)</button>
        <button id="btnRetryFromPause" class="btn">Re√Æncepe</button>
      </div>
    </div>
  </div>

  <div class="overlay" id="ovGameOver" aria-modal="true" role="dialog">
    <div class="panel">
      <h2>Game Over</h2>
      <p>Scor: <strong id="finalScore">0</strong> ‚Ä¢ Best: <strong id="finalBest">0</strong></p>
      <div class="grid">
        <button id="btnRetry" class="btn">RejoacƒÉ</button>
        <button id="btnMenu" class="btn">Meniu</button>
      </div>
    </div>
  </div>

  <canvas id="cv"></canvas>

  <script>
  (() => {
    const cv = document.getElementById('cv');
    const cx = cv.getContext('2d', { alpha: false, desynchronized: true });

    // DOM refs
    const elScore = document.getElementById('score');
    const elBest = document.getElementById('best');
    const elLives = document.getElementById('lives');
    const elLevel = document.getElementById('level');
    const pills = {
      score: document.getElementById('scorePill'),
      lives: document.getElementById('livesPill')
    };
    const hintEl = document.getElementById('hint');

    // Overlays & buttons
    const ovStart = document.getElementById('ovStart');
    const ovPause = document.getElementById('ovPause');
    const ovOver  = document.getElementById('ovGameOver');
    const btnStart = document.getElementById('btnStart');
    const btnPause = document.getElementById('btnPause');
    const btnResume = document.getElementById('btnResume');
    const btnRetryFromPause = document.getElementById('btnRetryFromPause');
    const btnRetry = document.getElementById('btnRetry');
    const btnMenu = document.getElementById('btnMenu');
    const btnMute = document.getElementById('btnMute');
    const finalScore = document.getElementById('finalScore');
    const finalBest = document.getElementById('finalBest');

    // Canvas size / DPR
    let DPR = 1, W = 1, H = 1;

    // Storage
    const LS_KEY = 'arc_target_best_v2';
    function getBest(){ const v = +localStorage.getItem(LS_KEY); return Number.isFinite(v) ? v : 0; }
    function setBest(v){ localStorage.setItem(LS_KEY, String(v)); }

    // Audio (tiny synth)
    let AC = null, audioEnabled = false, muted = false;
    function ensureAudio(){
      if (audioEnabled) return;
      try{
        AC = new (window.AudioContext || window.webkitAudioContext)();
        audioEnabled = true;
      }catch(e){ /* ignore */ }
    }
    function sfx(type, volume=0.18){
      if (!audioEnabled || muted || !AC) return;
      const o = AC.createOscillator();
      const g = AC.createGain();
      const now = AC.currentTime;
      let freq = 440, dur = .08, typeOsc = 'sine';
      switch(type){
        case 'shoot': freq = 520; dur=.06; typeOsc='triangle'; break;
        case 'hit': freq = 760; dur=.10; typeOsc='square'; break;
        case 'bull': freq = 980; dur=.16; typeOsc='sawtooth'; break;
        case 'miss': freq = 180; dur=.18; typeOsc='sine'; break;
        case 'pu': freq = 620; dur=.14; typeOsc='triangle'; break;
        case 'ui': freq = 420; dur=.07; typeOsc='square'; break;
        case 'pause': freq = 300; dur=.08; typeOsc='sine'; break;
      }
      o.type = typeOsc; o.frequency.value = freq;
      g.gain.setValueAtTime(0, now);
      g.gain.linearRampToValueAtTime(volume, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
      o.connect(g).connect(AC.destination);
      o.start(now);
      o.stop(now + dur + 0.02);
    }

    // Game objects
    const Game = {
      state: 'menu', // menu|playing|paused|over
      time: 0,
      level: 1,
      difficulty: 0, // grows slowly
      score: 0,
      best: getBest(),
      lives: 3,
      maxLives: 5,
      timeScale: 1,
      multiplier: 1,
      effects: {
        slow: 0,
        bigTarget: 0,
        double: 0
      }
    };

    // Entities
    const bow = { x: 56, y: 0, pull: 0, pulling: false };
    const arrow = { x: 0, y: 0, vx: 0, vy: 0, flying: false, trail: [] };
    const target = { x: 0, y: 0, r: 34, baseR: 34, vy: 1.2, phase: 0, swayAmp: 8 };
    const powerUps = []; // {x,y,r,type,vy,vx,ttl}
    const particles = []; // {x,y,vx,vy,life,clr,s,grav,fade}

    // Gesture state
    const gesture = { active:false, startX:0, startY:0, currX:0, currY:0, dx:0, dy:0, isTouch:false };

    // Keyboard
    const keys = { ArrowUp:false, ArrowDown:false, Space:false, Enter:false };

    function resetArrow(){
      arrow.x = bow.x;
      arrow.y = bow.y;
      arrow.vx = 0;
      arrow.vy = 0;
      arrow.flying = false;
      arrow.trail.length = 0;
    }

    function resetGame(){
      Game.time = 0;
      Game.level = 1;
      Game.difficulty = 0;
      Game.score = 0;
      Game.lives = 3;
      Game.multiplier = 1;
      Game.effects.slow = 0;
      Game.effects.bigTarget = 0;
      Game.effects.double = 0;
      target.baseR = Math.max(30, Math.min(W, H) * 0.04 + 20);
      target.r = target.baseR;
      target.vy = 1.2;
      target.phase = 0;
      target.swayAmp = 8;
      powerUps.length = 0;
      particles.length = 0;
      bow.pull = 0;
      bow.pulling = false;
      bow.y = H/2;
      target.x = Math.max(160, W - 110);
      target.y = H * 0.5;
      resetArrow();
      updateHUD();
      flashPill(pills.lives);
      flashPill(pills.score);
    }

    function updateHUD(){
      elScore.textContent = Game.score;
      Game.best = Math.max(Game.best, Game.score);
      elBest.textContent = Game.best;
      const hearts = '‚ù§'.repeat(Game.lives) + '¬∑'.repeat(Math.max(0, Game.maxLives - Game.lives));
      elLives.textContent = hearts;
      elLevel.textContent = Game.level;
    }

    function flashPill(el){
      el.style.transition = 'none';
      el.style.transform = 'scale(1.06)';
      el.style.filter = 'brightness(1.2)';
      requestAnimationFrame(()=>{
        el.style.transition = 'transform .15s ease, filter .3s ease';
        el.style.transform = 'scale(1)';
        el.style.filter = 'brightness(1)';
      });
    }

    function resize(){
      const r = cv.getBoundingClientRect();
      DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      W = Math.max(1, Math.floor(r.width));
      H = Math.max(1, Math.floor(r.height));
      if (cv.width !== Math.floor(W * DPR)) cv.width = Math.floor(W * DPR);
      if (cv.height !== Math.floor(H * DPR)) cv.height = Math.floor(H * DPR);
      cx.setTransform(DPR,0,0,DPR,0,0);
      bow.y = H/2;
      target.x = Math.max(160, W - 110);
      target.y = H * 0.5;
      resetArrow();
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    function getCanvasPos(clientX, clientY){
      const r = cv.getBoundingClientRect();
      return { x: clientX - r.left, y: clientY - r.top };
    }

    function normalizeEvent(e){
      let clientX, clientY, isTouch = false;
      if (e.touches && e.touches.length){
        clientX = e.touches[0].clientX; clientY = e.touches[0].clientY; isTouch = true;
      } else if (e.changedTouches && e.changedTouches.length){
        clientX = e.changedTouches[0].clientX; clientY = e.changedTouches[0].clientY; isTouch = true;
      } else {
        clientX = e.clientX; clientY = e.clientY;
        isTouch = e.pointerType === 'touch' || e.type.startsWith('touch');
      }
      return { clientX, clientY, isTouch, original: e };
    }

    function canShoot(){
      return Game.state === 'playing' && !arrow.flying;
    }

    function startPull(raw){
      ensureAudio();
      if (Game.state !== 'playing') return;
      const n = normalizeEvent(raw);
      if (arrow.flying) { raw.preventDefault(); return; }
      const pos = getCanvasPos(n.clientX, n.clientY);
      gesture.active = true;
      gesture.isTouch = n.isTouch;
      gesture.startX = gesture.currX = pos.x;
      gesture.startY = gesture.currY = pos.y;
      gesture.dx = 0; gesture.dy = 0;

      bow.pulling = true;
      bow.pull = 0;
      bow.y = Math.max(32, Math.min(H - 32, pos.y));
      raw.preventDefault();
      try { if (raw.pointerId != null) cv.setPointerCapture(raw.pointerId); } catch(err){}
    }

    function movePull(raw){
      const n = normalizeEvent(raw);
      if (!bow.pulling) return;
      const pos = getCanvasPos(n.clientX, n.clientY);
      gesture.currX = pos.x; gesture.currY = pos.y;
      gesture.dx = gesture.startX - gesture.currX; // left swipe -> positive
      gesture.dy = gesture.currY - gesture.startY;

      if (gesture.isTouch) {
        bow.pull = Math.max(0, Math.min(96, gesture.dx));
        bow.y += (pos.y - bow.y) * 0.35;
        bow.y = Math.max(32, Math.min(H - 32, bow.y));
      } else {
        bow.pull = Math.min(96, bow.pull + 2.4);
      }
      raw.preventDefault();
    }

    function endPull(raw){
      if (!bow.pulling || arrow.flying) return;
      bow.pulling = false;

      let power, vy;
      if (gesture.isTouch && (gesture.dx > 5 || Math.hypot(gesture.dx, gesture.dy) > 12)) {
        power = Math.min(32, 8 + Math.max(0, gesture.dx) * 0.12);
        vy = Math.max(-20, Math.min(20, gesture.dy * 0.04));
      } else {
        power = Math.min(32, 6 + bow.pull * 0.14);
        vy = (target.y - bow.y) * 0.015;
      }
      shoot(power, vy);
      try { if (raw.pointerId != null) cv.releasePointerCapture(raw.pointerId); } catch(err){}
      raw.preventDefault();
    }

    function shoot(power, vy){
      if (!canShoot()) return;
      arrow.x = bow.x;
      arrow.y = bow.y;
      arrow.vx = power;
      arrow.vy = vy;
      arrow.flying = true;
      bow.pull = 0;
      addMuzzleParticles(arrow.x, arrow.y);
      sfx('shoot', 0.12 + Math.min(0.1, power/400));
      if (navigator.vibrate) navigator.vibrate(10);
    }

    // Pointer + touch
    cv.addEventListener('pointerdown', startPull, { passive: false });
    cv.addEventListener('pointermove', movePull, { passive: false });
    cv.addEventListener('pointerup', endPull, { passive: false });
    cv.addEventListener('pointercancel', endPull, { passive: false });
    cv.addEventListener('touchstart', startPull, { passive: false });
    cv.addEventListener('touchmove', movePull, { passive: false });
    cv.addEventListener('touchend', endPull, { passive: false });
    cv.addEventListener('touchcancel', endPull, { passive: false });

    // Keyboard controls
    window.addEventListener('keydown', (e) => {
      if (e.repeat) return;
      ensureAudio();
      if (e.key === 'p' || e.key === 'P'){
        e.preventDefault();
        togglePause();
        return;
      }
      if (Game.state === 'menu' || Game.state === 'paused' || Game.state === 'over') return;
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.ArrowUp = true;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.ArrowDown = true;
      if (e.key === ' ' || e.key === 'Enter'){
        keys.Space = true;
        bow.pulling = true;
        bow.pull = 0;
        e.preventDefault();
      }
    }, { passive:false });

    window.addEventListener('keyup', (e) => {
      if (Game.state !== 'playing') return;
      if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') keys.ArrowUp = false;
      if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') keys.ArrowDown = false;
      if ((e.key === ' ' || e.key === 'Enter') && bow.pulling){
        keys.Space = false;
        bow.pulling = false;
        const power = Math.min(32, 6 + bow.pull * 0.14);
        const vy = (target.y - bow.y) * 0.015;
        shoot(power, vy);
      }
    });

    // UI buttons
    btnStart.addEventListener('click', () => {
      ensureAudio(); sfx('ui'); hideAllOverlays(); startGame();
    });
    btnPause.addEventListener('click', () => { togglePause(); });
    btnResume.addEventListener('click', () => { sfx('ui'); resumeGame(); });
    btnRetryFromPause.addEventListener('click', () => { sfx('ui'); hideAllOverlays(); startGame(); });
    btnRetry.addEventListener('click', () => { sfx('ui'); hideAllOverlays(); startGame(); });
    btnMenu.addEventListener('click', () => { sfx('ui'); showOverlay(ovStart); Game.state='menu'; });
    btnMute.addEventListener('click', () => {
      ensureAudio();
      muted = !muted;
      btnMute.setAttribute('aria-pressed', String(muted));
      btnMute.textContent = muted ? 'üîá Mut' : 'üîà Sunet';
      sfx('ui');
    });

    function hideAllOverlays(){
      [ovStart, ovPause, ovOver].forEach(o => o.classList.remove('show'));
    }
    function showOverlay(ov){
      hideAllOverlays();
      ov.classList.add('show');
    }

    function startGame(){
      resetGame();
      Game.state = 'playing';
      btnPause.textContent = 'PauzƒÉ';
      btnPause.setAttribute('aria-pressed','false');
      hintEl.style.opacity = '0.9';
      setTimeout(()=>{ hintEl.style.opacity = '0.45'; }, 3500);
    }

    function pauseGame(){
      if (Game.state !== 'playing') return;
      Game.state = 'paused';
      btnPause.textContent = 'ContinuƒÉ';
      btnPause.setAttribute('aria-pressed','true');
      showOverlay(ovPause);
      sfx('pause');
    }
    function resumeGame(){
      if (Game.state !== 'paused') return;
      Game.state = 'playing';
      hideAllOverlays();
      btnPause.textContent = 'PauzƒÉ';
      btnPause.setAttribute('aria-pressed','false');
      sfx('pause');
    }
    function togglePause(){
      if (Game.state === 'menu') return;
      if (Game.state === 'playing') pauseGame();
      else if (Game.state === 'paused') resumeGame();
    }
    function gameOver(){
      Game.state = 'over';
      setBest(Game.best);
      finalScore.textContent = Game.score;
      finalBest.textContent = Game.best;
      showOverlay(ovOver);
    }

    // Power-ups
    const PU_TYPES = ['slow', 'big', 'double']; // slow time, big target, double score
    function spawnPowerUp(x=undefined, y=undefined){
      const t = PU_TYPES[Math.floor(Math.random()*PU_TYPES.length)];
      const px = x ?? (W*0.4 + Math.random()*W*0.4);
      const py = y ?? (H*0.2 + Math.random()*H*0.6);
      const r = 14;
      const vx = (Math.random() < .5 ? -1 : 1) * (0.2 + Math.random()*0.4);
      const vy = (Math.random() < .5 ? -1 : 1) * (0.15 + Math.random()*0.3);
      powerUps.push({ x: px, y: py, r, type: t, vx, vy, ttl: 14 + Math.random()*8 });
    }

    function activatePowerUp(type){
      switch(type){
        case 'slow': Game.effects.slow = 7; break;
        case 'big': Game.effects.bigTarget = 7; break;
        case 'double': Game.effects.double = 10; Game.multiplier = 2; break;
      }
      sfx('pu', .22);
      if (navigator.vibrate) navigator.vibrate([10,40,10]);
      // Visual feedback
      for(let i=0;i<24;i++){
        const a = Math.random()*Math.PI*2;
        const sp = 0.8 + Math.random()*2.2;
        const c = type==='slow' ? '#7ecbff' : type==='big' ? '#ffd166' : '#a8ff8a';
        particles.push({x:target.x,y:target.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:0.6,clr:c,s:2.2,grav:0,fade:1});
      }
    }

    // Particles
    function addHitParticles(x,y,color,amount=20){
      for(let i=0;i<amount;i++){
        const a = Math.random()*Math.PI*2;
        const sp = 1 + Math.random()*2.8;
        const s  = 1.5 + Math.random()*2;
        particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:0.7+Math.random()*0.5,clr:color,s,grav:0.08,fade:1});
      }
    }
    function addMuzzleParticles(x,y){
      for(let i=0;i<8;i++){
        const a = (Math.random()-.5)*0.6;
        const sp = 1 + Math.random()*2;
        particles.push({x:x+10,y, vx: Math.cos(a)*sp+2, vy: Math.sin(a)*sp, life:.3+Math.random()*0.2, clr:'#ffd3a6', s:1.2, grav:0.02, fade:1});
      }
    }

    function circleHit(ax,ay,bx,by,br){ const dx=ax-bx, dy=ay-by; return (dx*dx + dy*dy) <= br*br; }

    // Update loop with dt
    let lastT = performance.now();
    function loop(now){
      const rawDt = Math.min(0.05, (now - lastT) / 1000);
      lastT = now;

      // Keep a little ambient animation even in menus
      const dt = rawDt * (Game.state === 'playing' ? (Game.timeScale * (Game.effects.slow>0 ? 0.6 : 1)) : 1);

      update(dt);
      draw();

      requestAnimationFrame(loop);
    }

    function update(dt){
      // Pull growth on keyboard hold
      if (Game.state === 'playing' && bow.pulling && !gesture.isTouch && !arrow.flying){
        bow.pull = Math.min(96, bow.pull + 120 * dt);
      }

      // Move bow with keys
      if (Game.state === 'playing'){
        const sp = 220 * dt;
        if (keys.ArrowUp) bow.y = Math.max(32, bow.y - sp);
        if (keys.ArrowDown) bow.y = Math.min(H - 32, bow.y + sp);
      }

      // Effects timers
      if (Game.effects.slow > 0){ Game.effects.slow = Math.max(0, Game.effects.slow - dt); }
      if (Game.effects.bigTarget > 0){ Game.effects.bigTarget = Math.max(0, Game.effects.bigTarget - dt); }
      if (Game.effects.double > 0){
        Game.effects.double = Math.max(0, Game.effects.double - dt);
        if (Game.effects.double === 0) Game.multiplier = 1;
      }

      // Difficulty progression (slow and steady up to long sessions)
      if (Game.state === 'playing'){
        Game.time += dt;
        const difRate = 0.015; // per second
        Game.difficulty += difRate * dt;
        // Level every 10 score or time milestones
        const levelByScore = Math.floor(Game.score / 12) + 1;
        const levelByTime = Math.floor(Game.time / 45) + 1;
        const newLevel = Math.max(levelByScore, levelByTime);
        if (newLevel !== Game.level){
          Game.level = newLevel;
          flashPill(pills.score);
          // chance to spawn powerup each level up
          if (Math.random() < 0.8) spawnPowerUp();
        }
      }

      // Target motion
      const baseVy = (1.1 + Game.difficulty*0.5) * (H/720);
      if (target.vy === 0) target.vy = baseVy;
      const swayAmp = 6 + Game.level * 1.2;
      target.phase += dt * (0.8 + Game.difficulty);
      const sway = Math.sin(target.phase) * swayAmp;
      target.y += (Game.state === 'playing' ? 1 : 0.4) * (target.vy + Math.sin(target.phase*0.6) * 0.2);
      if (target.y < 80 || target.y > H - 80) target.vy *= -1;
      // Slight horizontal sway for flavor
      const txBase = Math.max(160, W - 110);
      target.x = txBase + sway * 0.8;

      // Target size adjusts with difficulty + effect
      target.baseR = Math.max(20, 36 - Game.level * 1.2);
      const desiredR = target.baseR + (Game.effects.bigTarget>0 ? 12 : 0);
      target.r += (desiredR - target.r) * 0.15;

      // Arrow physics
      const gravity = 18 * dt * (1 + Game.difficulty*0.12) * (Game.effects.slow>0 ? 0.6 : 1);
      if (arrow.flying){
        // trail
        arrow.trail.push({x:arrow.x, y:arrow.y, life:0.4});
        if (arrow.trail.length > 24) arrow.trail.shift();

        arrow.x += arrow.vx;
        arrow.y += arrow.vy;
        arrow.vy += gravity * 0.06;

        // Power-up collision
        for(let i=powerUps.length-1;i>=0;i--){
          const pu = powerUps[i];
          if (circleHit(arrow.x,arrow.y,pu.x,pu.y,pu.r+4)){
            activatePowerUp(pu.type);
            powerUps.splice(i,1);
          }
        }

        // Collision with target
        const dx = arrow.x - target.x, dy = arrow.y - target.y;
        const d = Math.hypot(dx, dy);
        if (d < target.r){
          const ring = d / target.r; // 0 center .. 1 edge
          let pts = ring < 0.2 ? 5 : (ring < 0.4 ? 3 : (ring < 0.7 ? 2 : 1));
          pts *= Game.multiplier;
          Game.score += pts;
          Game.best = Math.max(Game.best, Game.score);
          elScore.textContent = Game.score;
          elBest.textContent = Game.best;
          // visual/audio feedback
          const col = ring < 0.33 ? '#ffcc00' : '#7ecbff';
          addHitParticles(arrow.x, arrow.y, col, 26);
          if (ring < 0.2){ sfx('bull', .18); if (Math.random() < 0.6) spawnPowerUp(arrow.x+20, arrow.y); }
          else sfx('hit', .16);
          if (navigator.vibrate) navigator.vibrate(ring < 0.33 ? [12, 20, 12] : 12);
          // Difficulty nudges
          Game.difficulty += 0.02;
          // bounce direction change
          target.vy = (target.y < H*0.5 ? Math.abs(target.vy) : -Math.abs(target.vy));
          resetArrow();
          flashPill(pills.score);
        }

        // Miss: arrow out of screen
        if (arrow.x > W + 30 || arrow.y < -30 || arrow.y > H + 30){
          resetArrow();
          if (Game.state === 'playing'){
            Game.lives--;
            sfx('miss', .12);
            addHitParticles(target.x-40, target.y, '#ff7b88', 14);
            updateHUD();
            if (navigator.vibrate) navigator.vibrate([15,60,15]);
            if (Game.lives <= 0){
              setBest(Game.best);
              gameOver();
              return;
            }
          }
        }
      } else {
        // Auto-follow to keep reachable when idle; reduced when user is interacting
        if (!bow.pulling && Game.state === 'playing'){
          bow.y += (target.y - bow.y) * 0.05;
        }
      }

      // Power-ups update
      for (let i=powerUps.length-1;i>=0;i--){
        const pu = powerUps[i];
        pu.x += pu.vx * (Game.effects.slow>0 ? 0.7 : 1);
        pu.y += pu.vy * (Game.effects.slow>0 ? 0.7 : 1);
        pu.ttl -= dt;
        if (pu.x < W*0.25 || pu.x > W-40) pu.vx *= -1;
        if (pu.y < 60 || pu.y > H-60) pu.vy *= -1;
        if (pu.ttl <= 0) powerUps.splice(i,1);
      }

      // Particles update
      for (let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vy += p.grav * (Game.effects.slow>0 ? 0.7 : 1);
        p.life -= dt;
        p.fade = Math.max(0, p.life);
        if (p.life <= 0) particles.splice(i,1);
      }

      // Occasional random pu while playing
      if (Game.state === 'playing' && Math.random() < 0.002 * (1 + Game.level*0.1)){
        spawnPowerUp();
      }
    }

    function draw(){
      // Clear background
      cx.fillStyle = '#0a0f1e';
      cx.fillRect(0,0,W,H);

      // vignette
      const grad = cx.createRadialGradient(W*0.6, H*0.5, Math.min(W,H)*0.2, W*0.6, H*0.5, Math.max(W,H)*0.9);
      grad.addColorStop(0, 'rgba(255,255,255,0.02)');
      grad.addColorStop(1, 'rgba(0,0,0,0.45)');
      cx.fillStyle = grad;
      cx.fillRect(0,0,W,H);

      // subtle parallax stars / rings
      cx.save();
      cx.globalAlpha = 0.10;
      cx.fillStyle = '#ffffff';
      for(let i=0;i<8;i++){
        const rr=60+i*40;
        cx.beginPath(); cx.arc(W-120,H*0.5,rr,0,Math.PI*2); cx.fill();
      }
      cx.restore();

      // Power-ups
      for(const pu of powerUps){
        cx.save();
        cx.translate(pu.x, pu.y);
        const glow = cx.createRadialGradient(0,0,2,0,0,16);
        const c1 = pu.type==='slow' ? '#7ecbff' : pu.type==='big' ? '#ffd166' : '#8cff9a';
        glow.addColorStop(0, c1 + 'cc');
        glow.addColorStop(1, c1 + '00');
        cx.fillStyle = glow;
        cx.beginPath(); cx.arc(0,0,16,0,Math.PI*2); cx.fill();
        cx.fillStyle = '#0a0f1e';
        cx.beginPath(); cx.arc(0,0,14,0,Math.PI*2); cx.fill();
        cx.strokeStyle = c1; cx.lineWidth = 2; cx.beginPath(); cx.arc(0,0,14,0,Math.PI*2); cx.stroke();
        cx.fillStyle = c1;
        cx.font = 'bold 13px system-ui,Segoe UI,Roboto';
        cx.textAlign = 'center'; cx.textBaseline = 'middle';
        cx.fillText(pu.type==='slow'?'S':(pu.type==='big'?'B':'x2'), 0, 1);
        cx.restore();
      }

      // Target rings
      const rings = [
        ['#ff5964', target.r],
        ['#ffffff', target.r*0.72],
        ['#ffcc00', target.r*0.42],
        ['#ffffff', target.r*0.22]
      ];
      // Effects glow
      if (Game.effects.double>0){
        cx.save();
        cx.shadowColor = '#9bff96';
        cx.shadowBlur = 16;
        cx.beginPath(); cx.arc(target.x, target.y, target.r+4, 0, Math.PI*2); cx.strokeStyle='rgba(168,255,154,.8)'; cx.lineWidth=2; cx.stroke();
        cx.restore();
      }
      if (Game.effects.slow>0){
        cx.save();
        cx.strokeStyle='rgba(126,203,255,.7)';
        cx.setLineDash([6,4]);
        cx.beginPath(); cx.arc(target.x, target.y, target.r+10, 0, Math.PI*2); cx.stroke(); cx.restore();
      }
      rings.forEach(([col,rad])=>{ cx.fillStyle=col; cx.beginPath(); cx.arc(target.x,target.y,rad,0,Math.PI*2); cx.fill(); });

      // Bow (arc)
      cx.strokeStyle=Game.effects.double>0?'#7aff8f':'#5aa0ff';
      cx.lineWidth=6;
      cx.beginPath(); cx.arc(bow.x, bow.y, 32, -Math.PI/2, Math.PI/2); cx.stroke();
      // String
      cx.strokeStyle='rgba(255,255,255,.85)'; cx.lineWidth=2; cx.beginPath(); cx.moveTo(bow.x, bow.y-32); cx.lineTo(bow.x + (bow.pull*0.8), bow.y); cx.lineTo(bow.x, bow.y+32); cx.stroke();

      // Arrow trail
      for(const t of arrow.trail){
        cx.globalAlpha = Math.max(0, t.life*1.5);
        cx.fillStyle = '#ffd3a6';
        cx.fillRect(t.x-6, t.y-1, 12, 2);
        t.life -= 0.03;
      }
      cx.globalAlpha = 1;

      // Arrow
      cx.save();
      cx.translate(arrow.x, arrow.y);
      const ang = arrow.flying ? Math.atan2(arrow.vy, arrow.vx) : (gesture.isTouch && bow.pulling ? Math.atan2(gesture.dy*0.8, Math.max(1, 12 + bow.pull)) : 0);
      cx.rotate(ang);
      cx.fillStyle='#e2b497'; cx.fillRect(-12,-2,24,4);
      cx.fillStyle='#f43f5e'; cx.beginPath(); cx.moveTo(12,0); cx.lineTo(18,3); cx.lineTo(18,-3); cx.closePath(); cx.fill();
      cx.restore();

      // Particles
      for (const p of particles){
        cx.globalAlpha = Math.max(0, p.fade);
        cx.fillStyle = p.clr;
        cx.beginPath(); cx.arc(p.x, p.y, p.s, 0, Math.PI*2); cx.fill();
      }
      cx.globalAlpha = 1;

      // UI effect timers bars near top-left of canvas (visual durations)
      const bars = [];
      if (Game.effects.slow>0) bars.push({name:'Slow', v:Game.effects.slow/7, col:'#7ecbff'});
      if (Game.effects.bigTarget>0) bars.push({name:'Big', v:Game.effects.bigTarget/7, col:'#ffd166'});
      if (Game.effects.double>0) bars.push({name:'x2', v:Game.effects.double/10, col:'#8cff9a'});
      if (bars.length){
        const bx = 12, by = Math.max(54, (parseFloat(getComputedStyle(document.querySelector('.hud')).top) || 10) + 48);
        bars.forEach((b, i)=>{
          const w = 80, h = 6, gap = 10;
          cx.fillStyle='rgba(255,255,255,.15)';
          cx.fillRect(bx, by + i*(h+gap), w, h);
          cx.fillStyle = b.col;
          cx.fillRect(bx, by + i*(h+gap), Math.max(0, b.v*w), h);
          cx.fillStyle='#dfe9ff';
          cx.font='bold 10px system-ui'; cx.textAlign='left'; cx.textBaseline='bottom';
          cx.fillText(b.name, bx, by + i*(h+gap) - 2);
        });
      }
    }

    // Start in menu
    elBest.textContent = Game.best;
    showOverlay(ovStart);

    requestAnimationFrame(loop);
  })();
  </script>
</body>
</html>