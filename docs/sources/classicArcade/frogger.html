<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Frogger Game</title>
  <style>
    :root { --bg:#0b0f17; --fg:#e5e7eb; }
    * { box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html, body { height:100%; margin:0; background:var(--bg); color:var(--fg); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    .wrap { height:100%; display:flex; align-items:center; justify-content:center; flex-direction:column; }
    .panel { text-align:center; padding:24px; border-radius:16px; }
    .stats { font-size:20px; font-weight:700; margin-bottom:16px; display:flex; gap:30px; justify-content:center; }
    .stats span { color:#60a5fa; }
    canvas { border:2px solid #1f2937; border-radius:8px; background:#0b1220; }
    .info { margin-top:16px; font-size:14px; opacity:0.8; }
    .controls { margin-top:20px; display:grid; grid-template-columns: repeat(3, 60px); gap:10px; justify-content:center; }
    .controls button { padding:15px; background:#1f2937; color:#fff; border:none; border-radius:8px; font-size:20px; font-weight:bold; cursor:pointer; }
    .controls button:active { background:#374151; }
    .controls .empty { visibility:hidden; }
    .restart-btn { margin-top:10px; padding:10px 20px; background:#60a5fa; color:#fff; border:none; border-radius:8px; font-weight:700; cursor:pointer; }
    .game-over { font-size:20px; color:#ef4444; margin-top:16px; font-weight:700; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <div class="stats">
        <div>Score: <span id="score">0</span></div>
        <div>Lives: <span id="lives">3</span></div>
        <div>Level: <span id="level">1</span></div>
      </div>
      <canvas id="game" width="480" height="480"></canvas>
      <!-- Inspired by classic Frogger arcade game -->
      <!-- Source reference: https://gist.github.com/straker/ff00b4b49669ad3dec890306d348adc4 -->
      <div class="info">Use arrow keys or buttons to move the frog</div>
      <div class="controls">
        <div class="empty"></div>
        <button id="up">↑</button>
        <div class="empty"></div>
        <button id="left">←</button>
        <button id="down">↓</button>
        <button id="right">→</button>
      </div>
      <div id="gameOver" class="game-over" style="display:none;">
        Game Over!
        <br>
        <button class="restart-btn" onclick="restartGame()">Restart</button>
      </div>
    </div>
  </div>
  <script>
    // Classic Frogger game implementation
    // Inspired by: https://gist.github.com/straker/ff00b4b49669ad3dec890306d348adc4
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');
    const gameOverEl = document.getElementById('gameOver');
    
    const gridSize = 40;
    const rows = canvas.height / gridSize;
    const cols = canvas.width / gridSize;
    
    let score = 0;
    let lives = 3;
    let level = 1;
    let gameRunning = true;
    
    // Frog position
    let frog = {
      x: Math.floor(cols / 2) * gridSize,
      y: (rows - 1) * gridSize,
      size: gridSize - 4
    };
    
    // Cars and logs
    let vehicles = [];
    let logs = [];
    
    // Lane configuration
    const lanes = [
      { y: 11, type: 'safe', speed: 0 },           // Starting area
      { y: 10, type: 'road', speed: 1, dir: 1 },   // Road lanes
      { y: 9, type: 'road', speed: 1.5, dir: -1 },
      { y: 8, type: 'road', speed: 1, dir: 1 },
      { y: 7, type: 'road', speed: 2, dir: -1 },
      { y: 6, type: 'safe', speed: 0 },            // Middle safe zone
      { y: 5, type: 'water', speed: 1, dir: 1 },   // Water lanes
      { y: 4, type: 'water', speed: 1.5, dir: -1 },
      { y: 3, type: 'water', speed: 1, dir: 1 },
      { y: 2, type: 'water', speed: 1.2, dir: -1 },
      { y: 1, type: 'water', speed: 1.5, dir: 1 },
      { y: 0, type: 'goal', speed: 0 }             // Goal area
    ];
    
    function initLevel() {
      vehicles = [];
      logs = [];
      
      // Create vehicles for road lanes
      lanes.forEach(lane => {
        if (lane.type === 'road') {
          for (let i = 0; i < 3; i++) {
            vehicles.push({
              x: i * 160 + Math.random() * 80,
              y: lane.y * gridSize,
              width: gridSize * 1.5,
              height: gridSize - 8,
              speed: lane.speed * lane.dir * (1 + level * 0.1),
              color: lane.dir > 0 ? '#ef4444' : '#f97316'
            });
          }
        } else if (lane.type === 'water') {
          for (let i = 0; i < 2; i++) {
            logs.push({
              x: i * 240 + Math.random() * 100,
              y: lane.y * gridSize,
              width: gridSize * (2 + Math.random()),
              height: gridSize - 8,
              speed: lane.speed * lane.dir * (1 + level * 0.1),
              color: '#8b4513'
            });
          }
        }
      });
    }
    
    function drawFrog() {
      ctx.fillStyle = '#10b981';
      ctx.fillRect(frog.x + 2, frog.y + 2, frog.size, frog.size);
      // Draw eyes
      ctx.fillStyle = '#fff';
      ctx.fillRect(frog.x + 8, frog.y + 8, 4, 4);
      ctx.fillRect(frog.x + 28, frog.y + 8, 4, 4);
    }
    
    function drawLanes() {
      lanes.forEach(lane => {
        if (lane.type === 'safe') {
          ctx.fillStyle = '#1f2937';
          ctx.fillRect(0, lane.y * gridSize, canvas.width, gridSize);
        } else if (lane.type === 'water') {
          ctx.fillStyle = '#1e40af';
          ctx.fillRect(0, lane.y * gridSize, canvas.width, gridSize);
        } else if (lane.type === 'road') {
          ctx.fillStyle = '#374151';
          ctx.fillRect(0, lane.y * gridSize, canvas.width, gridSize);
          // Draw lane lines
          ctx.strokeStyle = '#fbbf24';
          ctx.setLineDash([20, 10]);
          ctx.beginPath();
          ctx.moveTo(0, lane.y * gridSize + gridSize / 2);
          ctx.lineTo(canvas.width, lane.y * gridSize + gridSize / 2);
          ctx.stroke();
          ctx.setLineDash([]);
        } else if (lane.type === 'goal') {
          ctx.fillStyle = '#059669';
          ctx.fillRect(0, lane.y * gridSize, canvas.width, gridSize);
        }
      });
    }
    
    function drawVehicles() {
      vehicles.forEach(vehicle => {
        ctx.fillStyle = vehicle.color;
        ctx.fillRect(vehicle.x, vehicle.y + 4, vehicle.width, vehicle.height);
      });
    }
    
    function drawLogs() {
      logs.forEach(log => {
        ctx.fillStyle = log.color;
        ctx.fillRect(log.x, log.y + 4, log.width, log.height);
      });
    }
    
    function updateObjects() {
      // Update vehicles
      vehicles.forEach(vehicle => {
        vehicle.x += vehicle.speed;
        if (vehicle.speed > 0 && vehicle.x > canvas.width) {
          vehicle.x = -vehicle.width;
        } else if (vehicle.speed < 0 && vehicle.x < -vehicle.width) {
          vehicle.x = canvas.width;
        }
      });
      
      // Update logs
      logs.forEach(log => {
        log.x += log.speed;
        if (log.speed > 0 && log.x > canvas.width) {
          log.x = -log.width;
        } else if (log.speed < 0 && log.x < -log.width) {
          log.x = canvas.width;
        }
      });
    }
    
    function checkCollisions() {
      const frogRow = Math.floor(frog.y / gridSize);
      const currentLane = lanes.find(l => l.y === frogRow);
      
      if (!currentLane) return;
      
      // Check vehicle collisions
      if (currentLane.type === 'road') {
        for (let vehicle of vehicles) {
          if (frog.x < vehicle.x + vehicle.width &&
              frog.x + frog.size > vehicle.x &&
              frog.y < vehicle.y + vehicle.height &&
              frog.y + frog.size > vehicle.y) {
            loseLife();
            return;
          }
        }
      }
      
      // Check water - need to be on a log
      if (currentLane.type === 'water') {
        let onLog = false;
        for (let log of logs) {
          if (frog.x + 10 >= log.x &&
              frog.x + frog.size - 10 <= log.x + log.width &&
              frog.y >= log.y - 5 &&
              frog.y <= log.y + log.height + 5) {
            onLog = true;
            // Move frog with log
            frog.x += log.speed;
            break;
          }
        }
        if (!onLog) {
          loseLife();
          return;
        }
      }
      
      // Check if reached goal
      if (currentLane.type === 'goal') {
        score += 100 * level;
        scoreEl.textContent = score;
        level++;
        levelEl.textContent = level;
        resetFrog();
        initLevel();
      }
      
      // Check boundaries
      if (frog.x < 0 || frog.x > canvas.width - gridSize) {
        loseLife();
      }
    }
    
    function loseLife() {
      lives--;
      livesEl.textContent = lives;
      if (lives <= 0) {
        gameOver();
      } else {
        resetFrog();
      }
    }
    
    function resetFrog() {
      frog.x = Math.floor(cols / 2) * gridSize;
      frog.y = (rows - 1) * gridSize;
    }
    
    function gameOver() {
      gameRunning = false;
      gameOverEl.style.display = 'block';
    }
    
    function restartGame() {
      score = 0;
      lives = 3;
      level = 1;
      scoreEl.textContent = score;
      livesEl.textContent = lives;
      levelEl.textContent = level;
      gameOverEl.style.display = 'none';
      resetFrog();
      initLevel();
      gameRunning = true;
      gameLoop();
    }
    
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawLanes();
      drawLogs();
      drawVehicles();
      drawFrog();
    }
    
    function gameLoop() {
      if (!gameRunning) return;
      
      updateObjects();
      checkCollisions();
      draw();
      
      requestAnimationFrame(gameLoop);
    }
    
    // Controls
    function moveFrog(dx, dy) {
      if (!gameRunning) return;
      
      const newX = frog.x + dx * gridSize;
      const newY = frog.y + dy * gridSize;
      
      if (newX >= 0 && newX <= canvas.width - gridSize &&
          newY >= 0 && newY <= canvas.height - gridSize) {
        frog.x = newX;
        frog.y = newY;
        
        // Add points for moving forward
        if (dy < 0) {
          score += 10;
          scoreEl.textContent = score;
        }
      }
    }
    
    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp') moveFrog(0, -1);
      if (e.key === 'ArrowDown') moveFrog(0, 1);
      if (e.key === 'ArrowLeft') moveFrog(-1, 0);
      if (e.key === 'ArrowRight') moveFrog(1, 0);
    });
    
    // Button controls
    document.getElementById('up').addEventListener('click', () => moveFrog(0, -1));
    document.getElementById('down').addEventListener('click', () => moveFrog(0, 1));
    document.getElementById('left').addEventListener('click', () => moveFrog(-1, 0));
    document.getElementById('right').addEventListener('click', () => moveFrog(1, 0));
    
    // Initialize and start game
    initLevel();
    gameLoop();
  </script>
</body>
</html>