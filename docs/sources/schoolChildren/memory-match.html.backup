<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <title>Memory Match</title>
  <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg1:#FFE6F3;
      --bg2:#E6F7FF;
      --bg3:#FFF9CC;
      --primary:#FF7AB6;
      --secondary:#6EE7F5;
      --accent:#FFCB57;
      --success:#6EE7A7;
      --text:#2b2b2b;
      --cardFrontFrom:#A78BFA;
      --cardFrontTo:#60A5FA;
      --cardBackFrom:#FF9A9E;
      --cardBackTo:#FAD0C4;
      --shadow: 0 8px 20px rgba(0,0,0,.12);
    }
    *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
    html,body{ height:100%; margin:0; background:radial-gradient(1200px 900px at -10% -10%, var(--bg3), transparent 60%), radial-gradient(1200px 900px at 110% 10%, var(--bg2), transparent 60%), radial-gradient(1200px 900px at 50% 120%, var(--bg1), transparent 60%), linear-gradient(135deg, #fff, #fdf6ff); color:var(--text); font-family: 'Fredoka', system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    body::before{
      content:"";
      position:fixed; inset:0; pointer-events:none;
      background:
        radial-gradient(18px 18px at 10% 20%, rgba(255, 203, 87,.15) 0 60%, transparent 61%),
        radial-gradient(14px 14px at 80% 30%, rgba(110, 231, 245,.18) 0 60%, transparent 61%),
        radial-gradient(16px 16px at 30% 80%, rgba(255, 122, 182,.16) 0 60%, transparent 61%);
      animation: floatBubbles 10s ease-in-out infinite;
    }
    @keyframes floatBubbles{
      0%,100%{ transform: translateY(0); }
      50%{ transform: translateY(-12px); }
    }
    .wrap{ min-height:100%; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:18px; padding:16px; }
    h1{ margin:6px 0 0; font-size: clamp(24px, 6vw, 40px); font-weight:700; letter-spacing:.5px; background: linear-gradient(90deg, #ff6aa2, #ffcb57, #7dd3fc); -webkit-background-clip:text; background-clip:text; color: transparent; text-shadow: 0 2px 0 rgba(255,255,255,.5); }
    .subtitle{ font-size: clamp(14px, 3.5vw, 18px); opacity:.85; }
    .topbar{ display:flex; gap:12px; align-items:center; justify-content:center; flex-wrap:wrap; }
    .badge{
      display:inline-flex; align-items:center; gap:8px;
      background: #fff; padding: 10px 14px; border-radius: 999px; box-shadow: var(--shadow); font-weight:600;
    }
    .badge strong{ font-size:clamp(16px,4.5vw,20px); color:#1a1a1a; }
    .btn{
      background: linear-gradient(135deg, #FF7AB6, #FFB37A);
      color:#fff; border:none; padding:12px 16px; border-radius: 999px; font-weight:700; font-size: clamp(16px, 4.2vw, 18px);
      box-shadow: 0 8px 16px rgba(255,122,182,.35); cursor:pointer;
      transition: transform .15s ease, box-shadow .2s ease; touch-action: manipulation;
    }
    .btn:active{ transform: translateY(1px) scale(.98); }
    .btn:focus-visible{ outline: 3px solid rgba(110,231,165,.8); outline-offset: 2px; }
    .grid{
      display:grid; gap: clamp(10px, 2.8vw, 18px);
      grid-template-columns: repeat(auto-fit, minmax(clamp(88px, 22vw, 140px), 1fr));
      width: min(92vw, 720px); margin: 6px auto 10px;
    }
    .tile{ position:relative; aspect-ratio: 3/4; perspective: 900px; }
    .card{
      position:relative; width:100%; height:100%;
      transform-style:preserve-3d; will-change: transform;
      transition: transform .5s cubic-bezier(.2,.8,.25,1.2);
      border-radius: 18px; box-shadow: var(--shadow);
      cursor: pointer;
    }
    .card:focus-visible{ outline: 4px solid rgba(96,165,250,.75); outline-offset: 3px; }
    @media (hover:hover){
      .card:not(.flipped):hover{ transform: translateY(-4px) rotateX(4deg) rotateY(-4deg); }
    }
    .face{
      position:absolute; inset:0; backface-visibility:hidden; border-radius: 18px;
      display:flex; align-items:center; justify-content:center;
      font-size: clamp(34px, 10vw, 64px); user-select:none;
    }
    .front{
      background: radial-gradient(180px 140px at 20% 20%, rgba(255,255,255,.35) 0 40%, transparent 41%),
                  linear-gradient(145deg, var(--cardFrontFrom), var(--cardFrontTo));
      color:#fff; border: 3px solid rgba(255,255,255,.5);
      position:relative; overflow:hidden;
    }
    .front::after{
      content:"üéà";
      position:absolute; font-size: clamp(28px, 8vw, 42px);
      right:12px; bottom:8px; opacity:.65;
      transform: rotate(-12deg);
    }
    .back{
      background: linear-gradient(145deg, var(--cardBackFrom), var(--cardBackTo));
      color:#222; border: 3px solid rgba(255,255,255,.7);
      transform: rotateY(180deg);
    }
    .flipped{ transform: rotateY(180deg) scale(1.04); }
    .matched{
      animation: pop .45s ease-out;
      box-shadow: 0 0 0 0 rgba(110,231,165,.0), 0 0 0 0 rgba(110,231,165,.0), var(--shadow);
    }
    .matched .back{ box-shadow: inset 0 0 0 3px rgba(110,231,165,.8), inset 0 0 18px rgba(110,231,165,.55); }
    @keyframes pop{
      0%{ transform: rotateY(180deg) scale(1); }
      50%{ transform: rotateY(180deg) scale(1.12); }
      100%{ transform: rotateY(180deg) scale(1.04); }
    }
    .shake{ animation: shake .28s ease-in-out; }
    @keyframes shake{
      0%,100%{ transform: rotateY(180deg) translateX(0); }
      25%{ transform: rotateY(180deg) translateX(-6px); }
      50%{ transform: rotateY(180deg) translateX(6px); }
      75%{ transform: rotateY(180deg) translateX(-4px); }
    }
    /* Particle burst */
    .burst{
      position: fixed; left:0; top:0; pointer-events:none; width:0; height:0; z-index: 5;
    }
    .burst i{
      position:absolute; font-size: clamp(16px, 4vw, 22px); will-change: transform, opacity;
      animation: burst-move .8s ease-out forwards;
    }
    @keyframes burst-move{
      0%{ transform: translate(0,0) scale(1); opacity:1; }
      100%{ transform: translate(var(--dx), var(--dy)) scale(0.9); opacity:0; }
    }
    /* Win overlay */
    .overlay{
      position: fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background: rgba(255,255,255,.75); backdrop-filter: blur(6px);
      z-index: 10; visibility:hidden; opacity:0; transition: opacity .25s ease, visibility .25s ease;
    }
    .overlay.show{ visibility: visible; opacity:1; }
    .modal{
      background:#fff; border-radius: 22px; padding: 24px; width:min(92vw, 520px);
      box-shadow: 0 16px 40px rgba(0,0,0,.15); text-align:center;
    }
    .modal h2{ margin: 8px 0 4px; font-size: clamp(24px, 6vw, 36px); }
    .modal p{ margin: 6px 0 16px; font-size: clamp(16px, 4.5vw, 18px); }
    .trophy{ font-size: clamp(40px, 14vw, 72px); display:block; }
    .mini{ font-size: 14px; opacity:.7; }
    /* Confetti rain */
    .confetti{ position: fixed; inset:0; pointer-events:none; overflow:hidden; z-index:9; }
    .confetti span{
      position:absolute; top:-10vh; will-change: transform, opacity;
      animation: fall var(--dur) linear forwards, sway 2.2s ease-in-out infinite;
      font-size: clamp(16px, 3.8vw, 22px);
    }
    @keyframes fall{ to{ transform: translateY(110vh) rotate(360deg); opacity:1; } }
    @keyframes sway{
      0%,100%{ transform: translateX(0); }
      50%{ transform: translateX(var(--sx)); }
    }
    /* Accessibility */
    .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip: rect(0,0,0,0); border:0; }
    @media (prefers-reduced-motion: reduce){
      .card, .matched, .shake, .confetti span, .burst i{ animation: none !important; transition: none !important; }
      body::before{ animation: none; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Memory Match</h1>
    <div class="subtitle">Find all the happy pairs!</div>
    <div class="topbar">
      <div class="badge" aria-live="polite">Pairs found: <strong id="found">0</strong>/8</div>
      <button id="restart" class="btn" type="button" aria-label="Restart game">Restart üîÑ</button>
    </div>
    <div class="grid" id="grid" role="grid" aria-label="Memory cards grid"></div>
  </div>

  <div id="win" class="overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-labelledby="winTitle" aria-describedby="winDesc">
      <span class="trophy">üèÜüéâ</span>
      <h2 id="winTitle">Hooray! You did it!</h2>
      <p id="winDesc">You found all the pairs. Great memory!</p>
      <button class="btn" id="playAgain" type="button">Play Again ‚ñ∂Ô∏è</button>
      <div class="mini">Tip: Try to beat your last run!</div>
    </div>
  </div>

  <div id="confetti" class="confetti" aria-hidden="true"></div>
  <div id="live" class="sr-only" aria-live="polite"></div>

  <script>
    (() => {
      const EMOJIS = ['üê∂','üê±','ü¶ä','üêª','üêº','üêµ','ü¶Ñ','üê∏'];
      const PAIR_COUNT = 8;
      const grid = document.getElementById('grid');
      const foundEl = document.getElementById('found');
      const restartBtn = document.getElementById('restart');
      const overlay = document.getElementById('win');
      const playAgainBtn = document.getElementById('playAgain');
      const confettiBox = document.getElementById('confetti');
      const live = document.getElementById('live');

      let tiles = [];
      let first = null;
      let second = null;
      let lock = false;
      let found = 0;

      function shuffle(arr){
        for(let i = arr.length - 1; i > 0; i--){
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      function createCard(sym, idx){
        const tile = document.createElement('div');
        tile.className = 'tile';
        tile.setAttribute('role', 'gridcell');

        const card = document.createElement('div');
        card.className = 'card';
        card.tabIndex = 0;
        card.setAttribute('role', 'button');
        card.setAttribute('aria-label', 'Hidden card');
        card.dataset.index = idx;

        const front = document.createElement('div');
        front.className = 'face front';
        front.textContent = 'üéÅ';

        const back = document.createElement('div');
        back.className = 'face back';
        back.textContent = sym;

        card.appendChild(front);
        card.appendChild(back);
        tile.appendChild(card);
        return tile;
      }

      function announce(msg){
        live.textContent = '';
        requestAnimationFrame(() => { live.textContent = msg; });
      }

      function burstAt(x, y){
        const emojis = ['‚ú®','üíñ','üéâ','‚≠êÔ∏è','üéà'];
        const count = 12;
        const box = document.createElement('div');
        box.className = 'burst';
        box.style.left = x + 'px';
        box.style.top = y + 'px';
        for(let i=0;i<count;i++){
          const p = document.createElement('i');
          p.textContent = emojis[Math.floor(Math.random()*emojis.length)];
          const a = (Math.random() * Math.PI * 2);
          const dist = 40 + Math.random()*50;
          const dx = Math.cos(a) * dist;
          const dy = Math.sin(a) * dist;
          p.style.setProperty('--dx', dx + 'px');
          p.style.setProperty('--dy', dy + 'px');
          p.style.transform = 'translate(0,0)';
          box.appendChild(p);
        }
        document.body.appendChild(box);
        setTimeout(()=> box.remove(), 900);
      }

      function rainConfetti(){
        confettiBox.innerHTML = '';
        const pieces = 40;
        const icons = ['üéâ','‚ú®','üéä','üí´','üåü','üéà'];
        for(let i=0;i<pieces;i++){
          const s = document.createElement('span');
          s.textContent = icons[i % icons.length];
          s.style.left = Math.random()*100 + 'vw';
          s.style.setProperty('--dur', (6 + Math.random()*3) + 's');
          s.style.setProperty('--sx', (Math.random() < .5 ? '-' : '') + (5 + Math.random()*15) + 'vw');
          s.style.opacity = Math.random() * .6 + .4;
          confettiBox.appendChild(s);
        }
        setTimeout(() => { confettiBox.innerHTML = ''; }, 9000);
      }

      function vibrate(pattern){
        if(navigator.vibrate) navigator.vibrate(pattern);
      }

      function resetPick(){ first = null; second = null; lock = false; }

      function check(){
        lock = true;
        if(first.sym === second.sym){
          tiles[first.idx].matched = tiles[second.idx].matched = true;
          const c1 = first.el, c2 = second.el;
          c1.classList.add('matched');
          c2.classList.add('matched');
          found++;
          foundEl.textContent = found;
          announce('Match found!');

          // Particle burst at midpoint between two cards
          const r1 = c1.getBoundingClientRect();
          const r2 = c2.getBoundingClientRect();
          const mx = (r1.left + r1.right + r2.left + r2.right)/4;
          const my = (r1.top + r1.bottom + r2.top + r2.bottom)/4;
          burstAt(mx, my);
          vibrate([20, 40, 20]);

          setTimeout(() => {
            resetPick();
            if(found === PAIR_COUNT){
              setTimeout(() => showWin(), 300);
            }
          }, 350);
        } else {
          // Wiggle animation for mismatch
          first.el.classList.add('shake');
          second.el.classList.add('shake');
          vibrate(60);
          setTimeout(() => {
            first.el.classList.remove('flipped','shake');
            second.el.classList.remove('flipped','shake');
            resetPick();
          }, 650);
        }
      }

      function flip(card){
        if(lock) return;
        const idx = +card.dataset.index;
        const t = tiles[idx];
        if(t.matched) return;
        if(card.classList.contains('flipped')) return;

        card.classList.add('flipped');
        if(!first){
          first = { idx, sym: t.sym, el: card };
          return;
        }
        if(first && first.idx === idx) return;

        second = { idx, sym: t.sym, el: card };
        check();
      }

      function onGridActivate(e){
        const card = e.target.closest('.card');
        if(!card || !grid.contains(card)) return;
        flip(card);
      }

      function onGridKey(e){
        const card = e.target.closest('.card');
        if(!card) return;
        if(e.key === 'Enter' || e.key === ' '){
          e.preventDefault();
          flip(card);
        }
      }

      function showWin(){
        overlay.classList.add('show');
        overlay.setAttribute('aria-hidden', 'false');
        rainConfetti();
      }

      function hideWin(){
        overlay.classList.remove('show');
        overlay.setAttribute('aria-hidden', 'true');
      }

      function init(){
        hideWin();
        found = 0;
        foundEl.textContent = found;
        grid.innerHTML = '';
        first = second = null; lock = false;

        const set = shuffle([...EMOJIS, ...EMOJIS]);
        tiles = set.map(sym => ({ sym, matched:false }));

        tiles.forEach((t, idx) => {
          const el = createCard(t.sym, idx);
          grid.appendChild(el);
        });
        announce('New game. Find all the pairs!');
      }

      // Events
      grid.addEventListener('click', onGridActivate, { passive: true });
      grid.addEventListener('keydown', onGridKey);
      restartBtn.addEventListener('click', init);
      playAgainBtn.addEventListener('click', init);
      // Optional: close overlay on background tap
      overlay.addEventListener('click', (e) => {
        if(e.target === overlay) init();
      });

      // Start game
      init();
    })();
  </script>
</body>
</html>